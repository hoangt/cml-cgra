/*

   Instruction Generator
Author: Dipal Saluja
email: dsaluja@asu.edu
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Overview~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This module is responsible for generating the actual instructions that will be executed on the CGRA. It reads the dfgâ€™s generated by LLVM and RegiMap, analyzes them and generates instructions and configuration for the CGRA. 

Input: FINALNODEFILE REGI_EDGEFILE LLVMNODEFILE LLVMEDGEFILE OBJFILE PrologFile KernelFile EpilogFile X Y, where objfile is the statically compiled template file, X and Y are the CGRA configs

Output: config file, prolog, epilog and kernel, where the config while is responsible for initializing the CGRA with II, loop controlling node, Loop controlling PE.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~How it works~~~~~~~~~~~~~~~~~~~~~~~~~~~~

COMMAND: opcodegen FINALNODEFILE REGI_EDGEFILE LLVMNODEFILE LLVMEDGEFILE OBJFILE PrologFile KernelFile EpilogFile X Y


Normal Instruction Encoding / Decoding
31	30	29 28|	27   |	26	25	24|	23	22	21|	20	19|	18	17|	16	15|	14|	13|	12 |11	10	9	8	7	6	5	4	3	2	1	0
OpCode     |Predict|	   LMUX   |    RMUX   |   R1  |	  R2  |   RW  |	WE|	AB|	DB |				Immediate                   /write comparison result to controller
using the last bit as a flag to set the output of the comparison result on the line to the controller (used for supporting the while loop execution)

The constructor for a CGRA instruction is as follows

CGRA_Instruction(OPCode opc,int predic,PEInputMux LMuxSel,PEInputMux RMuxSel,
int RRegAdd1,int RRegAdd2, int WAdd, bool WE, int ImmVal, bool EDMAdd, bool DMData);


So to generate any instruction we need the following information (in order of constructor parameters)
1. opcode
2. predicate bit (NOT CLEAR)
3. Left Mux Selector 
4. Right Mux Selector
5. Input Register 1 number
6. Input Register 2 number 
7. Write Register number
8. Write to register enabled flag
9. Immediate Value
10. Address Bus assert flag
11. Data Bus assert flag

#################### How each field is set ########################
1. Opcode
To set the opcode we read the operation type for the node and set the opcode.
The getOpCode() function gives more insight as to how the opcodes are set

2. Predicate
its a //TODO

3. Left Mux Selector
This field defines where the first input operand for this instruction will come from.
getLMuxSelector() function explains how this selection is made

4. Right Mux Selector
This field defines where the second input operand for this instruction will come from.
getRMuxSelector() function explains how this selection is made

5. Input Register 1 number
If the LMUX for this instruction is set to REGISTER, we need to find out the register number this instruction will read from.

6. Input Register 2 number
If the RMUX for this instruction is set to REGISTER, we need to find out the register number this instruction will read from.

7. Write Register Number
If this instruction writes to a register, we need to get the register number that it will write to

8. Write to register enabled flag
If this instruction writes to the register file, we need to set this flag to 1, 0 otherwise
isWriteEnabled() explains this in detail

9. Immediate Value
If any of the MUX selectors is Immediate, we use the value stored here as the operand.
getImmediate() explains this in more detail

10. Address Bus assert flag
if the instruction needs to assert the address bus, we set it to 1, 0 otherwise
isAddressBusAssert() explains it in more detail  

11. Data Bus assert flag
if the instruction needs to assert the data bus, we set it to 1, 0 otherwise
isDataBusAssert() explains it in more detail  

~~~~~~~~~~~~~~~~~~LIST OF UTILITIES REQUIRED~~~~~~~~~~~~~~~~~
1. nodeid, operation type
2. edge, operand order
3. nodeid, name
4. nodeid, pe for kernel, prolog and epilog
5. nodeid, schedule_time for kernel, prolog, epilog
6. nodeid, generated Instruction
7. {time,pe}, node id for prolog, epilog and kernel
8. pe, number of memory operations
9. nodeid, register it writes to
10. in_edge
11. out_edge

*/

#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <cstring>
#include "CGRAInstruction.cpp"
#include <cstdlib>
#include <cmath>
#include <cstdio>

using namespace std;

//map for ddgs node id and type
std::map<int,int> nodeid_type;

//a vector of routing nodes
std::vector<int> routingNodes;

//map for ddgs node id and name
std::map<int,string> nodeid_names;

//map for ddgs node id and incoming edge's source node ids
std::multimap<int,int> in_edge;

//map for ddgs node id and outgoing edge's destination node ids
std::multimap<int,int> out_edge;

//map for edge, operand order
std::map< std::pair<int,int>,int> operand_order_map;

//The final generated instruction for a node
std::map<int,CGRA_Instruction> nodeid_instruction;

//array of prolog,kernel and epilog operation (in terms of node id from ddg)
int *prolog,*kernel,*epilog;

//array of final decoded prolog,kernel and epilog instructions
unsigned int *final_prolog,*final_kernel,*final_epilog;

int final_prolog_size,final_kernel_size,final_epilog_size;

//the load instructions for initializing the registers with ld/st address,
//<pe,set<instructions> >
std::multimap<int, std::vector<CGRA_Instruction> > initInstructions;

int prolog_size, kernel_size, epilog_size;

//a map of node_id,pe_num for prolog,kernel and epilog
std::map<int,int> prolog_map,kernel_map,epilog_map;

//a map for node_id, mapped time for prolog, kernel and epilog
std::map<int,int> node_time_map_prolog,node_time_map_kernel,node_time_map_epilog;

//a map for node_id, schedule time
std::map<int,int> node_schedule_time;

//a map of nodes scheduled at time
std::map<int, std::set<int> > schedule_time_nodes;

//a map for pe, freeRegisters
std::map< int, std::set<int> > pe_free_registers;

//a map for {pe,time}, registerAllocation for kernel
std::map< std::pair<int,int>, int> pe_time_Registers_map;

//a map storing the number of memory operations mapped to a pe, <pe,num_mem ops>
std::map<int,int> pe_mem_op_map;

//a map of node_id,reg_num it writes to for kernel
std::map<int, int> node_Output_Register;

//a set of nodes that have any of the operands from the Rotating RF
std::set<int> nodesThatReadRotatingRF;

//CGRA configuration
int X,Y;

//Initiation Interval
int II;

//max number of memory operations mapped to a PE
int maxMemoryOperations = 0;

//a map of nodeID, regNum for ld_add and st_add nodes. The register will hold
//the base address
std::map<int,int> mem_node_regNum;

//execution state of cgra
enum exec_state{
  state_prolog,
  state_kernel,
  state_epilog_start,
  state_epilog
};


//return the PE number given an index.
int getPE(int i)
{
  return (i%(X*Y));
}

int getTime(int i)
{
  return (i/(X*Y));
}


//get the mapped time of this node depending on the execution state
int getMappedTime(int id, exec_state state)
{
  int t=0;
  switch(state){
    case state_prolog:
      t = (node_time_map_prolog.find(id))->second;
      break;
    case state_kernel:
      t = (node_time_map_kernel.find(id))->second;
      break;
    case state_epilog_start:
      t = (node_time_map_kernel.find(id))->second;
      break;
    case state_epilog: 
      t = (node_time_map_epilog.find(id))->second;
      break;
    default: break;
  }

  return t;
}

//get the scheduled time of a node
int getScheduledTime(int id)
{
  return node_schedule_time[id];
}

//returns whether the operations are scheduled more than a cycle apart or not
bool isScheduledMoreThanACycleApart(int node1,int node2)
{
  int t1 = getScheduledTime(node1);
  int t2 = getScheduledTime(node2);
  return (abs(t1-t2) > 1);
}

//returns whether the operations are mapped more than a cycle apart or not
bool isMappedMoreThanACycleApart(int node1,int node2,exec_state state)
{
  int t1 = getMappedTime(node1,state);
  int t2 = getMappedTime(node2,state);
  if(state == state_kernel)
  {
    if((abs(t1-t2)+1) == II)
      return false;
  } 
  return (abs(t1-t2) > 1);
}


//get the PE number where this node is mapped depending on the state of execution
int getMappedPE(int id, exec_state state)
{
  int pe=0;
  switch(state){
    case state_prolog:
      pe = (prolog_map.find(id))->second;
      break;
    case state_kernel:
      pe = (kernel_map.find(id))->second;
      break;
    case state_epilog_start:
      pe = (kernel_map.find(id))->second;
      break;
    case state_epilog: 
      pe = (epilog_map.find(id))->second;
      break;
    default: break;
  }

  return pe;
}


//return the relative position of PE j wrt PE i
PEInputMux getRelativePosition(int i, int j)
{
  PEInputMux result = Up;

  int diff=i-j;

  if(diff == 0)
    result = Self;
  else if (diff == (1-Y) || diff == 1)
    result = Left;
  else if (diff == (Y-1) || diff == -1)
    result = Right;
  else if (diff == (Y*(1-X)) || diff == Y)
    result = Up;
  else if (diff == (Y*(X-1)) || diff == -Y)
    result = Down;
  else
  {}		

  return result;
}	


//extract number from a string
int extractNumber(string name)
{
  char* str = new char[name.length()+1];
  strcpy(str,name.c_str());
  int result;
  sscanf(str, "%*[^0123456789]%d",&result);
  return result;
}

//not to be used anymore
//extract number from a string using grep command defined in a script
/*int extractNumber(string name)
  {
  FILE *pipe;
  char result[80];
  string command;

  command = "/home/dipal/workspace/CGRA/scripts/extractnumber.sh ";
  command += name;

  if (( pipe = popen(command.c_str(), "r")) == NULL)
  {
  perror("popen");
  exit(1);
  }

  fgets(result,80,pipe);

  pclose(pipe);

  int value = atoi(result);

  return value;
  }
  */
//read the symbol table from obj, get the address of var and print it
int getVariableAddress(string var, string obj)
{
 

  FILE *pipe;
  char result[80];
  string command;


  command = "/home/mahesh/Documents/CGRA/toolchain/othertools/scripts/getaddress.sh ";
  command += obj + " " + var;

  if (( pipe = popen(command.c_str(), "r")) == NULL)
  {
    perror("popen");
    exit(1);
  }

  fgets(result,80,pipe);

  pclose(pipe);

  int addr=(int)strtol(result,NULL,16);
/*if (var == a) 
	addr = 602240; 
if (var == b) 
	addr = 602244; 
if (var == c)
	addr = 602248; 
if (var == d) 
	addr = 602260;*/ 

  return addr;

}

//read the symbol table from obj, get the address of var and print it


//get the operation type of the node
int getNodeType(int id)
{
  std::map<int, int>::iterator it = nodeid_type.find(id);
  return it->second;
}

//get the node id for the source operation of this routing node
int getRouteSrc(int id)
{
  std::multimap<int, int>::iterator it = in_edge.find(id);
  if(getNodeType(it->second) != route)
    return it->second;
  else
    getRouteSrc(it->second);
}

/*
 *this function is responsible to update the operand orders by incorporating the routing nodes generated by RegiMAP
 */

void updateOperandOrder()
{
  /*Steps:
   * get all routing nodes.
   * for each routing node, get all the outgoing edges
   *  for each outgoing edge, get the operand order from the source of this
   *  routing node to the destination of the edge.
   *  update the operand order map with 
   */

  for(int i=0;i<routingNodes.size();++i)
  {
    int node = routingNodes[i];
    int src = getRouteSrc(node);

    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = out_edge.equal_range(node);
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
      //edge from route to dest
      std::pair<int,int> edge1(node,it->second);

      //edge from src to dest
      std::pair<int,int> edge2(src,it->second);
      int operandOrder = operand_order_map[edge2];

      operand_order_map.insert(std::pair< std::pair<int,int>,int >(edge1,operandOrder));

    }      

  }
}

/*
   return the node id's of operands in the order of their appearance in the instruction
   */

std::vector<int> getOperands(int nodeID)
{
  std::vector<int> result;
  //we cant have more than 3 operands
  int temp[3];

  int nodeType = getNodeType(nodeID);
  if(nodeType != st_data && nodeType != ld_data)
  {
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = in_edge.equal_range(nodeID);
    int ctr = 0;
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
      std::pair<int,int> edge(it->second,nodeID);
      if(operand_order_map.count(edge) > 0)
      {
        temp[operand_order_map[edge]] = it->second;
        ctr++;
      }
    }

    for(int j =0;j<ctr;j++)
      result.push_back(temp[j]);
  }
  else
  {
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = in_edge.equal_range(nodeID);
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
        result.push_back(it->second);
    }
  }

  return result;

}

OPCode getOpCode(int nodeID)
{
  int type = getNodeType(nodeID);
  OPCode opcode;
  switch(type)
  {
    case add:
      opcode = Add;
      break;
    case sub: 
      opcode = Sub;
      break;
    case mult: 
      opcode = Mult;
      break;
    case regi_div:
      opcode = NOOP;
      break;
    case shiftl:
      opcode = cgraASL;
      break;
    case shiftr:
      opcode = cgraASR;
      break;
    case andop:
      opcode = AND;
      break;
    case orop:
      opcode = OR;
      break;
    case xorop:
      opcode = XOR;
      break;
    case cmpUGT:
    case cmpUGEQ:
    case cmpSGEQ:
    case cmpSGT:
      opcode = GT;
      break;

    case cmpEQ:
      opcode = EQ;
      break;
    case cmpNEQ:
      opcode = NEQ;
      break;
    case cmpULT:
    case cmpULEQ:
    case cmpSLEQ:
    case cmpSLT:
      opcode = LT;
      break;
    case ld_add:
    case ld_data:
    case st_data:
    case st_add:
      opcode = Add;
      break;
    case route:
      opcode = Add;
      break;

    default: opcode=NOOP;
             break;



             /*
                ld_add_cond,
                ld_data_cond,
                st_add_cond,
                st_data_cond,
                llvm_route,
                cgra_select,
                constant,
                loopctrl,
                rest*/

  }

  return opcode;

}


//TODO 
int getPredic(int nodeID)
{
  /*
     no info on this as of now
     returning 0
     */
  return 0;

}


//returns where the 1st operand of this instruction is going to come from
PEInputMux getLMuxSelector(int nodeID, exec_state state)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add
   result = REGISTER

   if the instruction is a ld_data
   result = DATABUS

   if the instruction is st_data
   {
   get the node id of the operand other than the varname and st_add
   if they are scheduled more than a cycle apart
   {
   result = REGISTER
   }
   else
   result = Relative PE position of the operand to the PE this node is mapped on
   }



   ***************Alu Operations**************
   Get the first operand (lets call it op)
   If(op is Constant)
   result = IMMEDIATE
   if(op is scheduled more than 1 cycle apart)
   result = REGISTER
   else
   result = Relative PE position of the operand to the PE this node is mapped on

   *****************Route Operation************
   get the nodeID of the src node in the edge in which this is the destination
   if they are scheduled more than a cycle apart
   result = REGISTER
   else
   result = Relative position of the PE of the src node to the PE this node is mapped to
   */

  PEInputMux result = Register;
  int nodetype = getNodeType(nodeID);
  vector<int> operands = getOperands(nodeID);
  int pe1,pe2;

  //there will be atmost 1 incoming edge to the routing node
  std::multimap<int, int>::iterator it_inedge = in_edge.find(nodeID);
  //MEMORY OPERATIONS
  switch(nodetype){

    case ld_add:
    case st_add:
      return result;
      break;
    case ld_data:
      result = DataBus;
      return result;
      break;
    case st_data:
      int operandID;
      for(std::vector<int>::iterator it = operands.begin(); it!= operands.end(); ++it)
      {
        if((getNodeType(*it) != st_add) && (getNodeType(*it) != constant))
          operandID = *it;
      }
      if(isScheduledMoreThanACycleApart(nodeID,operandID))
      {
        nodesThatReadRotatingRF.insert(nodeID);
        result = Register;
      }
      else
      {
        pe1 = getMappedPE(nodeID,state);	
        pe2 = getMappedPE(operandID,state);
        result = getRelativePosition(pe1,pe2);	
      }
      return result;
      break;
      //ROUTING NODE
    case route:
      if(isScheduledMoreThanACycleApart(nodeID,it_inedge->second))
      {
        nodesThatReadRotatingRF.insert(nodeID);
        result = Register;
      }
      else
      {
        pe1 = getMappedPE(nodeID,state);	
        pe2 = getMappedPE(it_inedge->second,state);
        result = getRelativePosition(pe1,pe2);	
      }
      return result;
      break;
    default:
      break;						

  }

  //ALU Operations 
  if(operands.size() > 0)
  {
    int operand1 = operands[0];
    int opType = getNodeType(operand1);
    if(opType == constant)
    {
      result = Immediate;
      return result;
    }

    if(isScheduledMoreThanACycleApart(nodeID,operand1))
    {
      nodesThatReadRotatingRF.insert(nodeID);
      result = Register;
      return result;
    }
    else
    {
      pe1 = getMappedPE(nodeID,state);	
      pe2 = getMappedPE(operand1,state);
      result = getRelativePosition(pe1,pe2);	
      return result;
    }

  }

}

//returns where the 2nd operand if this instruction is going to come from
PEInputMux getRMuxSelector(int nodeID,exec_state state)
{
  /*
   ************Memory Operations*******************
   if the instruction is ld_add, st_add
   {
   get all the operands of this node
   if(no operands)
   result = IMMEDIATE (set to 0)
   else
   {
   there will be atmost 1 operand for this instruction
   if the operand is constant
   result = IMMEDIATE (set to the constant value)
   if(the operand is scheduled more than a cycle apart)
   result = REGISTER
   else
   result =  Relative PE position of the operand to the PE this node is mapped on
   }
   }

   if the instruction is a ld_data
   result = immediate  (set immediate to 0)

   if the instruction is st_data
   result = immediate  (set immediate to 0)

   ***************Alu Operations**************
   Get the second operand (lets call it op)
   If(op is Constant)
   result = IMMEDIATE
   if(op is scheduled more than 1 cycle apart)
   result = REGISTER
   else
   result = Relative PE position of the operand to the PE this node is mapped on

   *****************Route Operation************
   result = Immediate (set to 0)

*/
  PEInputMux result = Register;
  int nodetype = getNodeType(nodeID);
  vector<int> operands = getOperands(nodeID);
  int pe1,pe2;

  switch(nodetype){
    //ROUTING NODE
    case route:
      //MEMORY OPERATIONS
    case ld_data:
    case st_data:
      result = Immediate;
      return result;
      break;
    case ld_add:
    case st_add:
      if(operands.size() == 0)
      {
        result = Immediate;
        return result;
      }
      else
      {
        int operand1 = operands[0];
        int opType = getNodeType(operand1);
        if(opType == constant)
        {
          result = Immediate;
          return result;
        }
        if(isScheduledMoreThanACycleApart(nodeID,operand1))
        {
          nodesThatReadRotatingRF.insert(nodeID);
          result = Register;
          return result;
        }
        else
        {
          pe1 = getMappedPE(nodeID,state);	
          pe2 = getMappedPE(operand1,state);
          result = getRelativePosition(pe1,pe2);	
          return result;
        }
      }

      break;
    default:
      break;						

  }

  //ALU Operations 
  if(operands.size() > 1)
  {
    int operand2 = operands[1];
    int opType = getNodeType(operand2);
    if(opType == constant)
    {
      result = Immediate;
      return result;
    }

    if(isScheduledMoreThanACycleApart(nodeID,operand2))
    {
      nodesThatReadRotatingRF.insert(nodeID);
      result = Register;
      return result;
    }
    else
    {
      pe1 = getMappedPE(nodeID,state);	
      pe2 = getMappedPE(operand2,state);
      result = getRelativePosition(pe1,pe2);	
      return result;
    }

  }

}

//this function is responsible for returning the register number a node writes
//to
int getOutputRegisterNumber(int node)
{
  int result=-1;
  if(node_Output_Register.count(node) > 0)
    result = (node_Output_Register.find(node))->second;

  return result;
}


//This function accepts the register number to which the src node writes to,
//computes the distance between the src and dest instruction and returns the
//register number the dest node should read from
//THE RF ROTATES TO THE LEFT
//0 1 2 3
//3 0 1 2
//2 3 0 1 
//1 2 3 0
//0 1 2 3
int getRotatingRegNum(int regNum,int src,int dest, exec_state state)
{

  int Tsrc,Tdest;

  Tsrc = getScheduledTime(src);
  Tdest = getScheduledTime(dest);

  int diff = abs(Tsrc - Tdest);
  int srcMappedTime = getMappedTime(src,state);
  int destMappedTime = getMappedTime(dest,state);
  int distance;
  /*
     1. diff <II
     src mapped b4 dest
     return same number
     src mapped after dest
     return number corresponding to 1 rotation
     2. diff >= II
     dist = floor(diff/II)
     src mapped b4 dest
     return number corresponding to dist rotation
     dest mapped b4 src
     return number corresponding to dist+11 rotation

*/

  if(diff < II)
  {
    if(srcMappedTime < destMappedTime)
    {
      return regNum;
    }
    else
    {
      distance = 1;
      return (regNum+(REGFILESIZE-distance))%REGFILESIZE;
    }
  }
  else
  {
    distance = floor(diff/II); 
    if(srcMappedTime < destMappedTime)
    {
      return (regNum+(REGFILESIZE-distance))%REGFILESIZE;
    }
    else
    {
      ++distance;
      return (regNum+(REGFILESIZE-distance))%REGFILESIZE;
    }
  }
}



//This function is responsible for returning the register number that will act
//as operand 1
int getReg1Address(int nodeID,PEInputMux LMux,exec_state state)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add
   result = register number this node is mapped to in mem_node_regNum

   if the instruction is a ld_data
   result = 0

   if the instruction is st_data
   {
   get the node id of the operand other than the varname and st_add
   if they are scheduled more than a cycle apart
   {
   reg=get the register that operand writes to
   result = getRotatingRegNum(reg,operandID,nodeID);
   }
   else
   result = 0
   }
   ***************Alu Operations**************
   Get the first operand (lets call it op)
   If(op is Constant)
   result = 0
   if(op is scheduled more than 1 cycle apart)
   reg=get the register that operand writes to
   result = getRotatingRegNum(reg,operandID,nodeID);
   else
   result =0

   *****************Route Operation************
   get the source node of the only incoming edge to this node
   if(src node is scheduled more than 1 cycle apart)
   reg=get the register that operand writes to
   result = getRotatingRegNum(reg,operandID,nodeID);
   else
   result =0

*/
  int result = 0;
  if(LMux == Register)
  {
    int opType = getNodeType(nodeID);

    //there will be atmost 1 incoming edge to the routing node
    std::multimap<int, int>::iterator it_inedge = in_edge.find(nodeID);
    vector<int> operands = getOperands(nodeID);

    switch(opType){
      //MEMORY OPERATIONS
      case ld_add:
      case st_add:
        result = mem_node_regNum[nodeID];
        return result;
        break;
      case ld_data:
        result = 0;
        return result;
        break;
      case st_data:
        int op;
        for(int i=0;i<operands.size();++i)
        {
          int type = getNodeType(operands[i]);
          if(type!=constant && type!=st_add)
          {
            op = operands[i];
            break;
          }    
        }
        if(isScheduledMoreThanACycleApart(nodeID,op))
        {
          int srcReg = getOutputRegisterNumber(op);
          result = getRotatingRegNum(srcReg,op,nodeID,state);
          return result;
        }
        else
        {
          result = 0;	
          return result;
        } 
        //ROUTING NODE        
      case route:
        if(isScheduledMoreThanACycleApart(nodeID,it_inedge->second))
        {
          int srcReg = getOutputRegisterNumber(it_inedge->second);
          result = getRotatingRegNum(srcReg,it_inedge->second,nodeID,state);
        }
        else
        {
          result = 0;
        }
        return result;
        break;

    }
    /*   ***************Alu Operations**************
         Get the first operand (lets call it op)
         If(op is Constant)
         result = 0
         if(op is scheduled more than 1 cycle apart)
         reg=get the register that operand writes to
         result = getRotatingRegNum(reg,operandID,nodeID);
         else
         result =0
         */
    if(operands.size() > 0)
    {
      int op1 = operands[0];
      int opType = getNodeType(op1);
      if(opType == constant)
        result == 0;

      if(isScheduledMoreThanACycleApart(nodeID,op1))
      {
        int srcReg = getOutputRegisterNumber(op1);
        result = getRotatingRegNum(srcReg,op1,nodeID,state);
      }
      else
      {
        result = 0;
      }

      return result;
    }

  }
  else
  {
    return 0;
  }

}


int getReg2Address(int nodeID,PEInputMux RMux,exec_state state)
{
  /*
   ************Memory Operations*******************
   if the instruction is ld_add, st_add
   {
   get all the operands of this node
   if(no operands)
   result = 0
   else
   {
   there will be atmost 1 operand for this instruction
   if the operand is constant
   result = 0
   if(the operand is scheduled more than a cycle apart)
   {
   reg = getSourceRegNum(operand)
   result = getRotatingRegNum(reg,operandID,nodeID)
   }
   else
   result = 0
   }
   }

   if the instruction is a ld_data
   result = 0

   if the instruction is st_data
   result = 0

   ***************Alu Operations**************
   Get the second operand (lets call it op)
   If(op is Constant)
   result = 0
   if(op is scheduled more than 1 cycle apart)
   {
   reg = getSourceRegNum(operand)
   result = getRotatingRegNum(reg,operandID,nodeID)
   }

   else
   result = 0

   *****************Route Operation************
   result = 0

*/
  if(RMux == Register)
  {
    int result = 0;
    int nodetype = getNodeType(nodeID);
    vector<int> operands = getOperands(nodeID);
    int pe1,pe2;

    switch(nodetype){
      //ROUTING NODE
      case route:
        //MEMORY OPERATIONS
      case ld_data:
      case st_data:
        result = 0;
        return result;
        break;
      case ld_add:
      case st_add:
        if(operands.size() == 0)
        {
          result = 0;
          return result;
        }
        else
        {
          int operand1 = operands[0];
          int opType = getNodeType(operand1);
          if(opType == constant)
          {
            result = 0;
            return result;
          }
          if(isScheduledMoreThanACycleApart(nodeID,operand1))
          {
            int srcreg = getOutputRegisterNumber(operand1);
            result = getRotatingRegNum(srcreg,operand1,nodeID,state);
            return result;
          }
          else
          {
            result = 0;	
            return result;
          }
        }

        break;
      default:
        break;						

    }

    //ALU Operations 
    if(operands.size() > 1)
    {
      int operand2 = operands[1];
      int opType = getNodeType(operand2);
      if(opType == constant)
      {
        result = 0;
        return result;
      }

      if(isScheduledMoreThanACycleApart(nodeID,operand2))
      {
        int srcreg = getOutputRegisterNumber(operand2);
        result = getRotatingRegNum(srcreg,operand2,nodeID,state);
        return result;
      }
      else
      {
        result = 0;	
        return result;
      }
    }
  }
  else
    return 0;
}

//TODO what if there are multiple dependents of the same operation and they use
//the register we are going to release
//this function releases registers consumed by this node and updates the
//<pe,freeRegisters> map
void releaseRegisters(int nodeID,exec_state state)
{
  /*
     check if this register reads from the Rotating RF
     get the operands for this instruction
     for each operand 
     if it writes to registers, get the reg num it writes to and the pe it is mapped to
     add that reg num to the free regs list of this pe

*/
  if(nodesThatReadRotatingRF.count(nodeID) > 0)
  {
    vector<int> operands = getOperands(nodeID);
    for(int i=0;i<operands.size();++i)
    {
      int op = operands[i];
      int regNum = getOutputRegisterNumber(op);

      if(regNum != -1)
      {
        int pe = getMappedPE(op,state);
        std::set<int> regs = pe_free_registers[pe];
        regs.insert(regNum);
        pe_free_registers[pe] = regs;
      }

    }
  }
}

//gives a free register for this PE and updates the map storing the free PE list
int getFreeRegister(int pe)
{
  std::set<int> freeRegs = pe_free_registers[pe];
  if(!freeRegs.empty())
  {
    int result = *freeRegs.begin();
    freeRegs.erase(freeRegs.begin());
    pe_free_registers[pe] = freeRegs;
    return result;
  }
  else
    return -1;
}




//This function is responsible for returning the register number this node is
//supposed to write to
int getWriteRegAddress(int nodeID,exec_state state)
{
  /*
   ***************Alu Operations, ld_data and Routing operations**************
   get the pe this node is mapped to
   get a free register from it
   return that

*/
  int pe = getMappedPE(nodeID,state);
  return getFreeRegister(pe);
}

bool isWriteEnabled(int nodeID)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add, st_data
   result = false

   ***************Alu Operations ld_data and ROUTE OPERATION**************
   {
   get the outgoing edges where this node is the source
   if any of the destination instructions are scheduled more than a cycle apart
   result = true
   else
   result = false
   }

*/
  bool result = false;
  int opType = getNodeType(nodeID);
  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
  //MEMORY OPERATIONS
  switch(opType){
    case ld_add:
    case st_add:
    case st_data:
      return false;
      break;
    default:
      break;
  }
  //ALU OPERATIONS,ld_data and route

  ret = out_edge.equal_range(nodeID);
  for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
  {

    if(isScheduledMoreThanACycleApart(nodeID,it->second))
    {
      result = true;
      break;
    }
  }
  return result;
}

//return the immediate value to be used for the instruction for this node
int getImmediate(int nodeID)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add
   {
   get operands
   if(no operands)
   result = 0
   else
   result = number extracted from the node name
   }

   if the instruction is a ld_data,st_data
   result = 0

   ***************Alu Operations**************
   get operands
   get the node id of the operand with operation_type = constant
   get the name of the node
   result = extract the immediate field from this name
   *****************Route Operation************
   result = 0

*/


  int result = 0;

  vector<int> operands = getOperands(nodeID);
  int nodetype = getNodeType(nodeID);
  switch(nodetype){
    //MEMORY OPERATIONS
    case ld_data:
    case st_data:
      //ROUTING NODE
    case route:
      return result;
      break;	
    case ld_add:
    case st_add:
      if(operands.size() == 0)
      {
        result = 0;
        return result;
      }
      else
      {
        for(int i=0;i<operands.size();++i)
        {
          if(getNodeType(operands[i]) == constant)
          {
            result = extractNumber(nodeid_names.find(operands[i])->second);
            return result;
          }
        }
      }
    default:
      break;
  }

  //ALU OPs
  if(operands.size() == 0)
  {
    result = 0;
    return result;
  }
  else
  {
    for(int i=0;i<operands.size();++i)
    {
      if(getNodeType(operands[i]) == constant)
      {
        result = extractNumber(nodeid_names.find(operands[i])->second);
        return result;
      }
    }
  }

  return result;
}

//return true this instruction needs to assert the address bus
bool isAddressBusAssert(int nodeID)
{
  /*
     if the instruction is ld_add,st_add
     result = true
     else 
     result = false
     */
  bool result = false;
  int nodetype = getNodeType(nodeID);
  if(nodetype == ld_add || nodetype == st_add)
    result = true;

  return result;
}

//return true this instruction needs to assert the data bus
bool isDataBusAssert(int nodeID)
{
  /*
     if the instruction is st_data 

     result = true
     else 
     result = false
     */
  bool result = false;
  if(getNodeType(nodeID) == st_data)
    result = true;	

  return result;
}


//get the name of the variable to be loaded (this function is called for a ld_add operation)
string getloadvarname(int id)
{
  /*
     a ld_add node has only one outgoing edge (dest).
     dest will have 2 incoming edges. One from ld_add and the other node indicating the variable name
     */
string name;
 
 if ( id == 0)
	name = "i";
 if (id == 3) 
	name = "a"; 
 if (id == 7) 
	name = "a";  

return name; 

}


//get the name of the variable to be stored (this function is called for a st_add operation)
string getstorevarname(int id)
{
  /*
     a st_add node has only one outgoing edge (dest).
     dest will have 3 incoming edges. One from st_add, one from an operation containing the value to be stored and the other node indicating the variable name
     */

string name; 

if (id == 5) 
	name = "c";
if (id == 9)
	name = "d";  
return name; 
}


//return the node id's of all the nodes performing a ld_add/st_add
vector<int> getMemoryNodes()
{
  vector<int> result;
  for(std::map<int, int>::iterator it = nodeid_type.begin(); it != nodeid_type.end(); ++it)
  {
    if(it->second == ld_add || it->second == st_add)
      result.push_back(it->first);
  }
  return result;
}

//TODO
void generateINITinstructions(char* objfile)
{
  /*
     This function is responsible for generating the LDi, LDMi and LDUi instructions that initialize the fixed RF with
     the load/store addresses
Steps:
1. Get a list of all the nodes performing a ld_add or st_add
2. for each node
{
pe = get the PE it is mapped to.
n = get the number of memory operations mapped to that PE
if(n>0)
reg_num = n;
else
reg_num = 0;
if(pe_mem_op_map.contains(pe))
pe_mem_op_map[pe]++;
else
pe_mem_op_map.insert(pe,1);

mem_node_regNum.insert(node,reg_num);

generate 3 instructions, LDi, LDMi and LDUi for the INIT state of this PE
varname = getld/st varname;
addr = get address of varname from the symbol table
  //the load immediate instructions have the LMUX as immediate and their WE set to 1.
  //the RW bits tell us the register number where we want to write the address
  //LDi
  immediate = addr & 0x00000fff
  //LDMi
  immediate = (addr & 0x00fff000) >> 12
  //LDUi
  immediate = (addr & 0xff000000) >>24

  }
  */

vector<int> mem_nodes = getMemoryNodes();
if(mem_nodes.size() > 0)
{
  for(int i=0;i<mem_nodes.size();++i)
  {
    int node = mem_nodes[i];

    int pe = getMappedPE(node, state_prolog);

    int num_mem_ops = (pe_mem_op_map.count(pe) == 0)?0: pe_mem_op_map[pe];
    int reg_num = num_mem_ops;

    mem_node_regNum[node] = reg_num;

    pe_mem_op_map[pe] = num_mem_ops+1;

    //update maxmemory operation count
    maxMemoryOperations = ((num_mem_ops+1) > maxMemoryOperations)? (num_mem_ops+1):maxMemoryOperations;

    string var = (getNodeType(node) == ld_add)? getloadvarname(node):getstorevarname(node);
    int addr =  getVariableAddress(var,objfile);

    printf("\n%x\t",addr);
    cout<<node<<"\t"<<pe<<"\t"<<addr<<"\t"<<reg_num<<endl;

    int LDi_imm = addr & 0x00000fff;
    int LDMi_imm = (addr & 0x00fff000) >> 12;
    int LDUi_imm = (addr & 0xff00000) >> 24;

    CGRA_Instruction LDi_ins(LDi,0,Immediate,Register,0,0,reg_num,1,LDi_imm,0,0);
    CGRA_Instruction LDMi_ins(LDMi,0,Immediate,Register,0,0,reg_num,1,LDMi_imm,0,0);
    CGRA_Instruction LDUi_ins(LDUi,0,Immediate,Register,0,0,reg_num,1,LDUi_imm,0,0);

    unsigned int dec1= LDi_ins.DecodeInstruction(&LDi_ins),dec2 = LDMi_ins.DecodeInstruction(&LDMi_ins), dec3 = LDUi_ins.DecodeInstruction(&LDUi_ins);

    printf("%x: %x: %x ",dec1,dec2,dec3);

    std::vector<CGRA_Instruction> ins_set;
    ins_set.push_back(LDi_ins);
    ins_set.push_back(LDMi_ins);
    ins_set.push_back(LDUi_ins);

    initInstructions.insert(std::pair<int,std::vector<CGRA_Instruction> >(pe,ins_set));

  }
}
}

//This function generates a no operation instruction
CGRA_Instruction generateNOOP()
{
  CGRA_Instruction noop(NOOP,0,Self,Self,0,0,0,0,0,0,0);
  return noop;
}


/*
   This function is responsible for generating prolog instructions
Steps:
1. get total prolog cycles
2. max_init_ins = get max number of memory ops mapped to a PE
3. total_init_cycles = max_init_ins*3
4. if((total_init_cycles%II) != 0), add a few noop cycles
This step is done to make sure that the registers are rotated a cycle before the actual prolog instructions start
5. for each pe, generate the init instructions and store the decoded instruction in the final_prolog array
6. add the dummy noop instructions
7. get the decoded prolog instructions and populate the final_prolog array
*/

void generateProlog()
{
  int total_cycles;
  int regi_prolog_cycles = prolog_size/(X*Y);
  int init_cycles = maxMemoryOperations*3;
  int noop_cycles=0;
  if(init_cycles%II != 0)
  {
    noop_cycles = II - (init_cycles%II);
  }
  total_cycles = init_cycles + noop_cycles + regi_prolog_cycles;

  final_prolog_size = total_cycles * X * Y;

  final_prolog = new unsigned int[final_prolog_size];

  CGRA_Instruction noop_ins = generateNOOP();
  unsigned int noop_decoded = noop_ins.DecodeInstruction(&noop_ins);

  //populate the final_prolog array with init instructions

  //FOR EACH PE
  for(int i=0; i<(X*Y); ++i)
  {   
    //FOR EACH MEM OPERATION
    if(initInstructions.count(i) > 0)
    {
      std::pair <std::multimap<int,std::vector<CGRA_Instruction> >::iterator, std::multimap<int,std::vector<CGRA_Instruction> >::iterator> ret;
      ret = initInstructions.equal_range(i);
      int j=0;

      //FOR EACH LD_IMM OPERATION
      for (std::multimap<int,std::vector<CGRA_Instruction> >::iterator it=ret.first; it!=ret.second; ++it)
      {
        std::vector<CGRA_Instruction> LDI_ins = it->second;
        for(int k = 0;k<LDI_ins.size(); ++k)
        {
          final_prolog[i + (X*Y)*j] = LDI_ins[k].DecodeInstruction(&LDI_ins[k]);
          j++;
        }
      }

      //fill the rest of init cycles with noops
      if(j < init_cycles)
      {
        while(j< init_cycles)
        {
          final_prolog[i + (X*Y)*j] = noop_decoded;
          j++;
        }
      }


    }

    //fll with only noops
    else
    {
      for(int j = 0;j<init_cycles;++j)
        final_prolog[i + (X*Y)*j] = noop_decoded;
    }
  }

  //populate the final_prolog array with dummy noop instructions

  if(noop_cycles > 0)
  {
    for(int i = 0; i< (X*Y); ++i)
    {
      for (int j = init_cycles; j < (init_cycles + noop_cycles) ; ++j)
      {
        final_prolog[i + (X*Y)*j] = noop_decoded;
      }
    }
  }

  int prolog_start = (init_cycles + noop_cycles) * (X*Y);

  for(int i =0; i<prolog_size; ++i)
  {
    if(prolog[i] == -1)
    {   
      final_prolog[prolog_start++] = noop_decoded;
    }
    else
    {
      CGRA_Instruction temp = nodeid_instruction[prolog[i]];
      final_prolog[prolog_start++] = temp.DecodeInstruction(&temp);
    }
  }

  cout<<"*******PROLOG*********\n";

  for(int i =0; i<final_prolog_size; ++i)
    printf("%d: %x\n",i,final_prolog[i]);
}

void generateKernel()
{
  final_kernel_size = kernel_size;
  final_kernel = new unsigned int[final_kernel_size];

  CGRA_Instruction noop_ins = generateNOOP();
  unsigned int noop_decoded = noop_ins.DecodeInstruction(&noop_ins);

  for(int i =0; i<kernel_size; ++i)
  {
    if(kernel[i] == -1)
    {   
      final_kernel[i] = noop_decoded;
    }
    else
    {
      CGRA_Instruction temp = nodeid_instruction[kernel[i]];
      final_kernel[i] = temp.DecodeInstruction(&temp);
    }
  }

  cout<<"*******KERNEl*********\n";

  for(int i =0; i<final_kernel_size; ++i)
    printf("%d: %x\n",i,final_kernel[i]);

}


void generateEpilog()
{
  final_epilog_size = epilog_size;
  final_epilog = new unsigned int[final_epilog_size];

  CGRA_Instruction noop_ins = generateNOOP();
  unsigned int noop_decoded = noop_ins.DecodeInstruction(&noop_ins);

  for(int i =0; i<epilog_size; ++i)
  {
    if(epilog[i] == -1)
    {   
      final_epilog[i] = noop_decoded;
    }
    else
    {
      CGRA_Instruction temp = nodeid_instruction[epilog[i]];
      final_epilog[i] = temp.DecodeInstruction(&temp);
    }
  }

  cout<<"*******EPILOG*********\n";

  for(int i =0; i<final_epilog_size; ++i)
    printf("%d: %x\n",i,final_epilog[i]);


}

void printSet(std::set<int> &arg)
{
  for(std::set<int>::iterator it = arg.begin(); it!=arg.end(); ++it)
    cout << *it << "\t";
} 

void generateInstructions(int node)
{
  OPCode opc;
  int predic = 0;
  PEInputMux lmux,rmux;
  int reg1=0,reg2=0,wreg=0;
  bool we,abAssert,dbAssert;
  int immediate=0;


  //	CGRA_Instruction(OPCode opc,int predic,PEInputMux LMuxSel,PEInputMux RMuxSel,\
  int RRegAdd1,int RRegAdd2, int WAdd, bool WE, int ImmVal, bool EDMAdd, bool DMData);

    opc = getOpCode(node);
    lmux = getLMuxSelector(node, state_prolog);
    rmux = getRMuxSelector(node, state_prolog);

    if(lmux == Register)
      reg1 = getReg1Address(node,lmux,state_kernel);
    else
      reg1 = 0;

    if(rmux == Register)
      reg2 = getReg2Address(node,rmux,state_kernel);
    else
      reg2 = 0;

    releaseRegisters(node,state_kernel);

    we = isWriteEnabled(node);
    if(we)
      wreg =getWriteRegAddress(node,state_prolog);
    else
      wreg = 0;
    node_Output_Register[node] = wreg;
    immediate = getImmediate(node);

    abAssert = isAddressBusAssert(node);
    dbAssert = isDataBusAssert(node);
    printf("\nFOR NODE %d:opcode:%d lmux:%d rmux:%d reg1:%d reg2:%d we:%d wreg:%d imm:%d ab:%d db:%d\n",node,opc,lmux,rmux,reg1,reg2,we,wreg,immediate,abAssert,dbAssert);

    CGRA_Instruction node_ins(opc,predic,lmux,rmux,reg1,reg2,wreg,we,immediate,abAssert,dbAssert);

    nodeid_instruction[node] = node_ins;


    unsigned int decoded = node_ins.DecodeInstruction(&node_ins);
    printf("\nDecoded %x",decoded);

}

void dumpProlog()
{
  FILE* prologFile;
  prologFile = fopen("prolog_ins.bin","wb");
  fwrite(&final_prolog_size,sizeof(int),1,prologFile);
  fwrite(final_prolog,sizeof(int),final_prolog_size,prologFile);
  fclose(prologFile);
}
void dumpKernel()
{
  FILE* kernelFile;
  kernelFile = fopen("kernel_ins.bin","wb");
  fwrite(&final_kernel_size,sizeof(int),1,kernelFile);
  fwrite(final_kernel,sizeof(int),final_kernel_size,kernelFile);
  fclose(kernelFile);
}
void dumpEpilog()
{
  FILE* epilogFile;
  epilogFile = fopen("epilog_ins.bin","wb");
  fwrite(&final_epilog_size,sizeof(int),1,epilogFile);
  fwrite(final_epilog,sizeof(int),final_epilog_size,epilogFile);
  fclose(epilogFile);
}

//driver function
int main(int argc, char* argv[])
{
  if(argc<11)
  {
    cout << "Usage opcodegen FINALNODEFILE REGI_EDGEFILE LLVMNODEFILE LLVMEDGEFILE OBJFILE PrologFile KernelFile EpilogFile X Y";
    return -1;
  }

  //CGRA DIMENSIONS
  X = atoi(argv[9]);
  Y = atoi(argv[10]);

  string line, nodename;
  int nodeID,node_type,other_nodeID;

  //Read the final node file
  ifstream finalnodefile (argv[1]);
  if(finalnodefile.is_open())
  {
    while ( getline(finalnodefile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> node_type;
      nodeid_type.insert(std::pair<int,int>(nodeID,node_type));
      if(node_type == route)
        routingNodes.push_back(nodeID);
    }
  }
  finalnodefile.close();


  //read the Edge file dumped by RegiMap
  ifstream regiEdgeFile (argv[2]);
  if(regiEdgeFile.is_open())
  {
    while ( getline(regiEdgeFile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> other_nodeID;
      cout<<"\nUPDATING EDGES " <<other_nodeID<<":"<<nodeID<<endl;
      out_edge.insert(std::pair<int,int>(nodeID,other_nodeID));
      in_edge.insert(std::pair<int,int>(other_nodeID,nodeID));
    }
  }
  regiEdgeFile.close();

  //read the node file dumped by llvm (dfg generator) to get the name of nodes
  //(used for constant nodes)
  ifstream llvmNodeFile (argv[3]);
  if(llvmNodeFile.is_open())
  {
    while ( getline(llvmNodeFile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> node_type >> nodename ;
      nodeid_names.insert(std::pair<int,string>(nodeID,nodename));
    }
  }
  llvmNodeFile.close();


  //read the llvm generated edge file
  //populate the out edge and in edge maps.
  //populate the operand orders

  //IMPORTANT: The out_edge and in_edge map contain the edges genrated by RegiMap
  //and the edges from the constant nodes to the other nodes.

  ifstream llvmEdgeFile (argv[4]);
  if(llvmEdgeFile.is_open())
  {
    while ( getline(llvmEdgeFile,line) )
    {
      int operandOrder,distance;
      string dependencyType;
      istringstream strout(line);
      strout >> nodeID >> other_nodeID >> distance >> dependencyType >> operandOrder;
      std::pair<int,int> outGoingEdge(nodeID,other_nodeID);
      operand_order_map.insert(std::pair< std::pair<int,int>,int >(outGoingEdge,operandOrder));
      if(getNodeType(nodeID) == constant)
      {
        cout<<"\nUPDATING EDGES " <<other_nodeID<<":"<<nodeID<<endl;
        out_edge.insert(std::pair<int,int>(nodeID,other_nodeID));
        in_edge.insert(std::pair<int,int>(other_nodeID,nodeID));
      }
    }
  }
  llvmEdgeFile.close();

  //update the operand orders to incorporate routing nodes from the dfg
  //generated by RegiMAP
  updateOperandOrder();

  //read the prolog file
  int opID,num_ops,i=0; 
  ifstream prologFile (argv[6]);
  if(prologFile.is_open())
  {
    while ( getline(prologFile,line) )
    {
      istringstream strout(line);
      strout >> prolog_size;
    }
    prolog = new int[prolog_size];  	    
  }
  prologFile.close();
  II = prolog_size/(X*Y);

  prologFile.open(argv[6], ifstream::in);
  cout << "file ptr: "<<prologFile.tellg()<<"\topen: "<<prologFile.is_open() <<"\t PrologSize: "<< prolog_size<<endl;
  if(prologFile.is_open())
  {
    while ( getline(prologFile,line) )
    {
      istringstream strout(line);
      strout >> opID;
      if(i<prolog_size)
        prolog[i++] = opID;
    }
  } 
 cout <<"********Prolog End*****************\n";
  prologFile.close();


  //read the kernel file
  i=0;
  ifstream kernelFile (argv[7]);
  if(kernelFile.is_open())
  {
    while ( getline(kernelFile,line) )
    {
      istringstream strout(line);
      strout >> kernel_size;
    }
    kernel = new int[kernel_size];  	    
  }
  kernelFile.close();
  int numRegisters,sched_t,max_schedule_time=0;
  kernelFile.open(argv[7], ifstream::in);
  if(kernelFile.is_open())
  {
    while ( getline(kernelFile,line) )
    {
      if(i<kernel_size)
      {
        istringstream strout(line);
        strout >> opID >> numRegisters >> sched_t;

        int t=getTime(i);
        int pe=getPE(i);

        if(opID != -1)
        {
          cout<<opID<<"\t"<<sched_t<<endl;
          node_schedule_time[opID] = sched_t;

          max_schedule_time = (sched_t>max_schedule_time)?sched_t:max_schedule_time;

          if(schedule_time_nodes.count(sched_t) > 0)
          {

            std::set<int> operations = schedule_time_nodes[sched_t];
            operations.insert(opID);
            schedule_time_nodes[sched_t] = operations;
          }
          else
          {
            std::set<int> operations;
            operations.insert(opID);
            schedule_time_nodes[sched_t] = operations;
          }
        }
        std::pair<int,int> pe_t(pe,t);
        pe_time_Registers_map[pe_t] = numRegisters;
        kernel[i++] = opID;
      }
    }
  }  
  kernelFile.close();


  //read the epilog file
  i=0;
  ifstream epilogFile (argv[8]);
  if(epilogFile.is_open())
  {
    while ( getline(epilogFile,line) )
    {
      istringstream strout(line);
      strout >> epilog_size;
    }
    epilog = new int[epilog_size];  	    
  }
  epilogFile.close();
  epilogFile.open(argv[8], ifstream::in);
  if(epilogFile.is_open())
  {
    while ( getline(epilogFile,line) )
    {
      istringstream strout(line);
      strout >> opID;
      if(i<epilog_size)
        epilog[i++] = opID;
    }
  }  
  epilogFile.close();

  //POPULATE THE PROLOG, KERNEL and EPILOG related maps
  cout << prolog_size << endl << kernel_size<<endl<<epilog_size<<endl;		
  for(int j=0;j<prolog_size;j++)
  {
    if(prolog[j] != -1)
    {
      int pe,t,node;
      pe = getPE(j);
      node = prolog[j];
      t = getTime(j);
      std::pair<int,int> pe_time(pe,t);
      node_time_map_prolog.insert(std::pair<int,int>(node,t));
      prolog_map.insert(std::pair<int,int>(node,pe));
    }
  }

  cout<<"*********KERNEL*****************\n";
  for(int j=0;j<kernel_size;j++)
  {
    if(kernel[j] != -1)
    {
      int pe,t,node;
      pe = getPE(j);
      node = kernel[j];
      t = getTime(j);
      std::pair<int,int> pe_time(pe,t);
      node_time_map_kernel.insert(std::pair<int,int>(node,t));
      kernel_map.insert(std::pair<int,int>(node,pe));
    }
  }

  cout<<"*********EPILOG*****************\n";
  for(int j=0;j<epilog_size;j++)
  {
    if(epilog[j] != -1)
    {
      int pe,t,node;
      pe = getPE(j);
      node = epilog[j];
      t = getTime(j);
      std::pair<int,int> pe_time(pe,t);
      node_time_map_epilog.insert(std::pair<int,int>(node,t));
      epilog_map.insert(std::pair<int,int>(node,pe));
    }
  }

  int totalPEs = X*Y;
  std::set<int> freeRegs;
  for(int i=0;i<REGFILESIZE;++i)
  {
    freeRegs.insert(i);
  }
  //initialize the free registers ma for each PE
  for(int i=0;i<totalPEs;++i)
  {
    pe_free_registers[i] = freeRegs;
  } 

  generateINITinstructions(argv[5]);

  for(int i=3; i<=5; i++)
  {

 
  if (i=3) {
       cout<<"\nNODES SCHEDULED AT "<<i<<"\n";
      generateInstructions(0);
      generateInstructions(3);
      generateInstructions(7);}
  if (i=4) {
       cout<<"\nNODES SCHEDULED AT "<<i<<"\n";
      generateInstructions(1);
      generateInstructions(4);
      generateInstructions(8); }
  if (i=5)
  {   
      cout<<"\nNODES SCHEDULED AT "<<i<<"\n";
      generateInstructions(5);
      generateInstructions(6);
      generateInstructions(9); 
      generateInstructions(10); 
  }
 }



  generateProlog();
  generateKernel();
  generateEpilog();

  dumpProlog();
  dumpKernel();
  dumpEpilog();

  return 0;
}
