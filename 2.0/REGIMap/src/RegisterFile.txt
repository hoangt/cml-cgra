Author: Dipal Saluja
email: dsaluja@asu.edu

************Introduction**********
In this document I am trying to elaborate on how to implement register file
contrained mapping using REGIMap. 
We are trying to do it for 3 types of register files.
1. NonProgrammable Register File
    In this register file each PE of the CGRA has a fixed number of rotating and
    Non rotating registers
2. Programmable Register File
    In this register file each PE of the CGRA has a fixed number of registers.
    Apart from the registers used for storing data, there is a register that
    stores the boundary value of this programmable RF. Based on the boundary,
    some of the registers of the register file can be accessed ad rotating and
    some of them can be accessed as non rotating registers.
3. Shared Register File
    In this register file each PE of the CGRA has a fixed number of Rotating
    Registers and each row of the CGRA has a register file containing fixed
    number of Non Rotating registers. All the PEs in a row have access to this
    shared Register File

***********Compiler support for these Register Files************

REGIMap generates a weighted graph representing compatibility graph of the
mapping pairs. Each mapping pair contains a Node from the input DFG and a time
extended PE. The arcs in the compatibility graph represent the compatibility
between placement of two nodes on two PEs at some time. The weight of the arcs
represent the number of registers required between these two placements to work.
For the sake of implementation, we use an adjacency matrix to represent the
graph. Hence, a valus of 1 represents that the placements are compatible. We
modify the same adjacency matrix to also represent the number of register
required. So the actual number of registers required would be the value in the
adjacency matrix - 1.

To generate a mapping Regimap finds a maximal clique of size equal to the number
of nodes in the input DFG. It also makes sure that all the nodes from the input
DFG are mapped.

During the generation of this clique, we check for register file constraints.
That is the area we will modify to include the new register file constraints to
do the mapping. In the following sections I describe the kinds of modifications
we need to do for each kind of register file

1. NonProgrammable Register File
   For every operation that we try to add to a cover we need to check for
   register file constraints. For non programmable register file we have X
   number of rotating register and X number of non rotating registers(NRR). The
   NRR are supposed to be used for storing constants such as memory pointers to
   global variables. This introduces a restriction on the capabilities of the
   PEs in a CGRA. Each PE can now perform only X number of memory operations. 

   The mapper generates many cliques of various sizes. During the generation of
   each clique the mapper needs to keep a track of the number of memory
   operations mapped to a PE. If selection of a vertex satisfies the new
   constraint we add it to the clique and update the number of memory operations
   mapped to that PE

2. Programmable Register File
   For every operation that we try to add to a cover we need to check for
   register file constraints. For Programmable register file we have X
   number of registers in each PE. Depending on the operations mapped to a PE,
   we can have a logical boundary in the RF between rotating and non rotating
   registers 

   The mapper generates many cliques of various sizes. During the generation of
   each clique the mapper keeps a track of the number of registers required by a
   PE at each cycle. The mapper also needs to keep a track of the number of memory
   operations mapped to a PE. So the total of registers required by the modulo
   schedule and Mem Ops cannot exceed X.
   If selection of a vertex satisfies the new
   constraint we add it to the clique and update the number of memory operations
   mapped to that ROW


3. Shared Register File
   For every operation that we try to add to a cover we need to check for
   register file constraints. For Shared register file we have X
   number of rotating register in each PE and Y number of non rotating
   registers(NRR) in a shared RF in each row of the CGRA. The
   NRR are supposed to be used for storing constants such as memory pointers to
   global variables. This introduces a restriction on the capabilities of the
   PEs in a CGRA. PEs in each row of the CGRA can now perform only Y number of memory operations. 

   The mapper generates many cliques of various sizes. During the generation of
   each clique the mapper needs to keep a track of the number of memory
   operations mapped to a ROW. If selection of a vertex satisfies the new
   constraint we add it to the clique and update the number of memory operations
   mapped to that ROW

