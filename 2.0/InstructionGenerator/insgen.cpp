/*

   Instruction Generator
Author: Dipal Saluja
email: dsaluja@asu.edu
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Overview~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This module is responsible for generating the actual instructions that will be executed on the CGRA. It reads the dfgâ€™s generated by LLVM and RegiMap, analyzes them and generates instructions and configuration for the CGRA. 

Input: FINALNODEFILE REGI_EDGEFILE LLVMNODEFILE LLVMEDGEFILE OBJFILE PrologFile KernelFile EpilogFile X Y, where objfile is the statically compiled template file, X and Y are the CGRA configs

Output: config file, prolog, epilog and kernel, where the config while is responsible for initializing the CGRA with II, loop controlling node, Loop controlling PE.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~How it works~~~~~~~~~~~~~~~~~~~~~~~~~~~~

COMMAND: opcodegen FINALNODEFILE REGI_EDGEFILE LLVMNODEFILE LLVMEDGEFILE OBJFILE PrologFile KernelFile EpilogFile X Y


Normal Instruction Encoding / Decoding
31	30	29 28|	27   |	26	25	24|	23	22	21|	20	19|	18	17|	16	15|	14|	13|	12 |11	10	9	8	7	6	5	4	3	2	1	0
OpCode     |Predict|	   LMUX   |    RMUX   |   R1  |	  R2  |   RW  |	WE|	AB|	DB |				Immediate                   /write comparison result to controller
using the last bit as a flag to set the output of the comparison result on the line to the controller (used for supporting the while loop execution)

The constructor for a CGRA instruction is as follows

CGRA_Instruction(OPCode opc,int predic,PEInputMux LMuxSel,PEInputMux RMuxSel,
int RRegAdd1,int RRegAdd2, int WAdd, bool WE, int ImmVal, bool EDMAdd, bool DMData);


So to generate any instruction we need the following information (in order of constructor parameters)
1. opcode
2. predicate bit (NOT CLEAR)
3. Left Mux Selector 
4. Right Mux Selector
5. Input Register 1 number
6. Input Register 2 number 
7. Write Register number
8. Write to register enabled flag
9. Immediate Value
10. Address Bus assert flag
11. Data Bus assert flag

#################### How each field is set ########################
1. Opcode
To set the opcode we read the operation type for the node and set the opcode.
The getOpCode() function gives more insight as to how the opcodes are set

2. Predicate
its a //TODO

3. Left Mux Selector
This field defines where the first input operand for this instruction will come from.
getLMuxSelector() function explains how this selection is made

4. Right Mux Selector
This field defines where the second input operand for this instruction will come from.
getRMuxSelector() function explains how this selection is made

5. Input Register 1 number
If the LMUX for this instruction is set to REGISTER, we need to find out the register number this instruction will read from.

6. Input Register 2 number
If the RMUX for this instruction is set to REGISTER, we need to find out the register number this instruction will read from.

7. Write Register Number
If this instruction writes to a register, we need to get the register number that it will write to

8. Write to register enabled flag
If this instruction writes to the register file, we need to set this flag to 1, 0 otherwise
isWriteEnabled() explains this in detail

9. Immediate Value
If any of the MUX selectors is Immediate, we use the value stored here as the operand.
getImmediate() explains this in more detail

10. Address Bus assert flag
if the instruction needs to assert the address bus, we set it to 1, 0 otherwise
isAddressBusAssert() explains it in more detail  

11. Data Bus assert flag
if the instruction needs to assert the data bus, we set it to 1, 0 otherwise
isDataBusAssert() explains it in more detail  

~~~~~~~~~~~~~~~~~~LIST OF UTILITIES REQUIRED~~~~~~~~~~~~~~~~~
1. nodeid, operation type
2. edge, operand order
3. nodeid, name
4. nodeid, pe for kernel, prolog and epilog
5. nodeid, schedule_time for kernel, prolog, epilog
6. nodeid, generated Instruction
7. {time,pe}, node id for prolog, epilog and kernel
8. pe, number of memory operations
9. nodeid, register it writes to
10. in_edge
11. out_edge

*/

#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <cstring>
#include "CGRAInstruction.cpp"
#include <cstdlib>
#include <cmath>
#include <cstdio>

using namespace std;

//map for ddgs node id and type
std::map<int,int> nodeid_type;

//a vector of routing nodes
std::vector<int> routingNodes;

//map for ddgs node id and name
std::map<int,string> nodeid_names;

//map for ddgs node id and incoming edge's source node ids
std::multimap<int,int> in_edge;

//map for ddgs node id and outgoing edge's destination node ids
std::multimap<int,int> out_edge;

//map for edge, operand order
std::map< std::pair<int,int>,int> operand_order_map;

//The final generated instruction for a node
std::map<int,CGRA_Instruction> nodeid_instruction;

//array of prolog,kernel and epilog operation (in terms of node id from ddg)
int *prolog,*kernel,*epilog, *livevar_store;

//array of final decoded prolog,kernel and epilog instructions
unsigned int *final_prolog,*final_kernel,*final_epilog, *final_livevar_store;


int final_prolog_size,final_kernel_size,final_epilog_size, final_livevar_store_size;

//the load instructions for initializing the registers with ld/st address,
//<pe,set<instructions> >
std::multimap<int, std::vector<CGRA_Instruction> > initInstructions;

int prolog_size, kernel_size, epilog_size;

//a map of node_id,pe_num for prolog,kernel and epilog
std::map<int,int> prolog_map,kernel_map,epilog_map;

//a map for node_id, mapped time for prolog, kernel and epilog
std::map<int,int> node_time_map_prolog,node_time_map_kernel,node_time_map_epilog;

//a map for node_id, schedule time
std::map<int,int> node_schedule_time;

//a map of nodes scheduled at time
std::map<int, std::set<int> > schedule_time_nodes;

//a map for pe, freeRegisters
std::map< int, std::set<int> > pe_free_registers;

//a map for {pe,time}, registerAllocation for kernel
std::map< std::pair<int,int>, int> pe_time_Registers_map;

//a map storing the number of memory operations mapped to a pe, <pe,num_mem ops>
std::map<int,int> pe_mem_op_map;

//a map of node_id,reg_num it writes to for kernel
std::map<int, int> node_Output_Register;

//a set of nodes that have any of the operands from the Rotating RF
std::set<int> nodesThatReadRotatingRF;

//map for ddgs to_node id in the edge file (only if it is phi node) and dependency distance of edge
std::map<int,int> to_node_dependency_distance;

//map for ddgs phi/select node in the node file and its condition variable
std::map<int,bool> select_node_condition;

//map for ddgs phi/select node in the node file and its local counter
std::map<int,int> select_node_counter;

//map for ddgs phi/select node in the node file and its corresponding result (finally selected node's ID)
std::map<int,int> select_constant_node_result;
std::map<int,int> select_phi_node_result;

std::map<int,PEInputMux> lmux_phi;
std::map<int,PEInputMux> rmux_phi;
std::map<int,int> immediate_phi;

//The final generated instruction for a node for prolog
std::map<int,CGRA_Instruction> nodeid_instruction_prolog;

//CGRA configuration
int X,Y;

//Initiation Interval
int II;

int kernel_II;

//max number of memory operations mapped to a PE
int maxMemoryOperations = 0;

//max number of memory operations mapped to a PE for array
int maxArrayMem = 0;

//total array operations
int ArrayOperations = 0;  

//a map of nodeID, regNum for ld_add and st_add nodes. The register will hold
//the base address
std::map<int,int> mem_node_regNum;

//data for live variables
//map for livevariables' node index and id
std::map<int,int> livevar_node_list;

//map for livevariables' node id and type
std::map<int,int> livevar_nodeid_type;

//map for livevariables' node id and name
std::map<int,string> livevar_nodeid_names;

//map for livevariables' node id and incoming edge's source node ids
std::multimap<int,int> livevar_in_edge;

//map for livevariables' node id and outgoing edge's destination node ids
std::multimap<int,int> livevar_out_edge;

//map for livevariables' edge, operand order
std::map< std::pair<int,int>,int> livevar_operand_order_map;

//The final generated instruction for a livevariable store node
std::map<int,CGRA_Instruction> livevar_nodeid_instruction;

//a map for livevariable's node_id, schedule time
std::map<int,int> livevar_node_schedule_time;

//map for livevariables' node id and mapped pe
std::map<int,int> livevar_pe_map;

//a map of nodes scheduled at time
std::map<int, std::set<int> > time_pe_map_livevar;

//execution state of cgra
enum exec_state{
  state_prolog,
  state_kernel,
  state_epilog_start,
  state_epilog
};

//size of the array to be initialized
//int size_array = 0;


//return the PE number given an index.
int getPE(int i)
{
  return (i%(X*Y));
}

int getTime(int i)
{
  return (i/(X*Y));
}

int getNodeType(int id)
{
  std::map<int, int>::iterator it = nodeid_type.find(id);
  return it->second;
}

string getNodeName(int id)
{
  std::map<int, string>::iterator it = nodeid_names.find(id);
  return it->second;
}

int getDepenDistance(int id)
{
  std::map<int, int>::iterator it = to_node_dependency_distance.find(id);
  return it->second;
}

int getSelCondition(int id)
{
  std::map<int, bool>::iterator it = select_node_condition.find(id);
  return it->second;
}

int getSelCounter(int id)
{
  std::map<int, int>::iterator it = select_node_counter.find(id);
  return it->second;
}

int getSelectedConstantNode(int id)
{
  std::map<int, int>::iterator it = select_constant_node_result.find(id);
  return it->second;
}

int getSelectedPhiNode(int id)
{
  std::map<int, int>::iterator it = select_phi_node_result.find(id);
  return it->second;
}

int getPhiNode(int id)
{
  int ret = -1;
  std::map<int, int>::iterator it;
  for(it = select_phi_node_result.begin(); it != select_phi_node_result.end(); ++it)
  {
 	if(it->second == id) 
	{
		ret = it->first;	//select_phi_node_result.find(id);
		return ret;
		break;
	}
  }	
  return ret;
}

void setlmuxphi(int id, PEInputMux result)
{
    std::map<int, PEInputMux>::iterator it = lmux_phi.find(id);
    it->second = result; 
}

void setrmuxphi(int id, PEInputMux result)
{
    std::map<int, PEInputMux>::iterator it = rmux_phi.find(id);
    it->second = result; 
}

void setimmediatephi(int id, int result)
{
    std::map<int, int>::iterator it = immediate_phi.find(id);
    it->second = result; 
}

PEInputMux getlmuxphi(int id)
{
    std::map<int, PEInputMux>::iterator it = lmux_phi.find(id);
    return it->second; 
}

PEInputMux getrmuxphi(int id)
{
    std::map<int, PEInputMux>::iterator it = rmux_phi.find(id);
    return it->second; 
}

int getimmediatephi(int id)
{
    std::map<int, int>::iterator it = immediate_phi.find(id);
    return it->second; 
}

int getLiveNodeType(int id)
{
  std::map<int, int>::iterator it = livevar_nodeid_type.find(id);
  return it->second;
}

string getLiveNodeName(int id)
{
  std::map<int, string>::iterator it = livevar_nodeid_names.find(id);
  return it->second;
}

int getLiveNode(int id)
{
  std::map<int, int>::iterator it = livevar_node_list.find(id);
  return it->second;
}

int getLiveVarMappedPE(int id)
{
  std::map<int, int>::iterator it = livevar_pe_map.find(id);
  return it->second;
}

int isLiveStoreNode(int id)
{
  string nodename = getNodeName(id);
  if((nodename.find("st_add") != string::npos) || (nodename.find("st_data") != string::npos))
    return 1;
  else 
    return 0;
}

//get the scheduled time of a node
int getScheduledTime(int id)
{
  return node_schedule_time[id];
}

//returns whether the operations are scheduled more than a cycle apart or not
bool isScheduledMoreThanACycleApart(int node1,int node2)
{
  int t1 = getScheduledTime(node1);
  int t2 = getScheduledTime(node2);
  return (abs(t1-t2) > 1);
}


//get the PE number where this node is mapped depending on the state of execution
int getMappedPE(int id, exec_state state)
{
  int pe=0;
  switch(state){
    case state_prolog:
      pe = (prolog_map.find(id))->second;
      break;
    case state_kernel:
      pe = (kernel_map.find(id))->second;
      break;
    case state_epilog_start:
      pe = (kernel_map.find(id))->second;
      break;
    case state_epilog: 
      pe = (epilog_map.find(id))->second;
      break;
    default: break;
  }

  return pe;
}


//return the relative position of PE j wrt PE i
PEInputMux getRelativePosition(int i, int j)
{
  PEInputMux result = Up;

  int diff=i-j;

  if(diff == 0)
    result = Self;
  else if (diff == (1-Y) || diff == 1)
    result = Left;
  else if (diff == (Y-1) || diff == -1)
    result = Right;
  else if (diff == (Y*(1-X)) || diff == Y)
    result = Up;
  else if (diff == (Y*(X-1)) || diff == -Y)
    result = Down;
  else
  {}		

  return result;
}	


//extract number from a string
int extractNumber(string name)
{
  char* str = new char[name.length()+1];
  strcpy(str,name.c_str());
  int result;
  sscanf(str, "%*[^0123456789]%d",&result);
  return result;
}

//not to be used anymore
//extract number from a string using grep command defined in a script
/*int extractNumber(string name)
  {
  FILE *pipe;
  char result[80];
  string command;

  command = "/home/dipal/workspace/CGRA/scripts/extractnumber.sh ";
  command += name;

  if (( pipe = popen(command.c_str(), "r")) == NULL)
  {
  perror("popen");
  exit(1);
  }

  fgets(result,80,pipe);

  pclose(pipe);

  int value = atoi(result);

  return value;
  }
  */
//read the symbol table from obj, get the address of var and print it
int getVariableAddress(string var,string obj)
{

  FILE *pipe;
  char result[80];
  string command;
  int addr_array[50]; 
  int i=0; 


  command = "/home/shail/CGRA/scripts/getaddress.sh ";
  command += obj + " " + var;

  if (( pipe = popen(command.c_str(), "r")) == NULL)
  {
    perror("popen");
    exit(1);
  }

  fgets(result,80,pipe);

  pclose(pipe);

  int addr=(int)strtol(result,NULL,16);
 
  return addr;

}

int extractlimit_from_node(int node)
{
 
 int result;
 //int nodeType =  getNodeType(node); 
 std::multimap<int, int>::iterator it = in_edge.find(node);
 std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret; 
 ret = in_edge.equal_range(node); 
   for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
    {
     int nodeType = getNodeType(it2->second); 
     if (nodeType == constant) 
      {
       std::map<int, string>::iterator nameit = nodeid_names.find(it2->second);
       result = extractNumber(nameit->second); 
      	 break; 
       }
    }
  return result;  

}


/*int getlimit(int nodeID) 
{
 vector<int> operands = getOperands(nodeID);
 int result=0;
 //opc = getOpCode(nodeID);   
 for(std::map<int, int>::iterator it = nodeid_type.begin(); it != nodeid_type.end(); ++it)
  {
   if(nodeID == 2) 
    {
      if(operands.size() == 0)
      {
        result = 0;
        return result;
      }
      else
      {
        for(int i=0;i<operands.size();++i)
        {
          if(getNodeType(operands[i]) == constant)
          {
            result = extractNumber(nodeid_names.find(operands[i])->second);
            return result;
	    break; 
          }
	}
     }
   }
  }
 return result; 
}*/


std::vector<int> getOperands(int nodeID)
{
  std::vector<int> result;
  //we cant have more than 3 operands
  int temp[3];

  int nodeType = getNodeType(nodeID);
  if(nodeType != st_data && nodeType != ld_data)
  {
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = in_edge.equal_range(nodeID);
    int ctr = 0;

    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
      std::pair<int,int> edge(it->second,nodeID);

      if(operand_order_map.count(edge) > 0)
      {
        //temp[operand_order_map[edge]] = it->second;
        temp[ctr] = it->second;
        ctr++;
      }
    }

    for(int j =0;j<ctr;j++) 
      result.push_back(temp[j]); 
  }
  else
  {
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = in_edge.equal_range(nodeID);
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
        result.push_back(it->second);
    }
  }

  return result;

}


//get the mapped time of this node depending on the execution state
int getMappedTime(int id, exec_state state)
{
  int t=0;
  
  if(isLiveStoreNode(id))
  {
    //Currently We Assume That This Function Will Be Required To Be Called By Store_Data; Possibility of Store_Add is To Be Checked
    int node_sched_time = node_schedule_time[id];
    string nodename = getNodeName(id);
    if((nodename.find("st_data") != string::npos))
    {
      int op;
      vector<int> operands = getOperands(id);
      for(int i=0;i<operands.size();++i)
      {
        int type = getNodeType(operands[i]);
        if(type!=constant && type!=st_add)
        {
          op = operands[i];
          break;
        }    
      }
      int op_sched_time = node_schedule_time[op];
      int op_map_time = getMappedTime(op,state);
      t = op_map_time + (node_sched_time - op_sched_time); 	 
    } 
  }
  else
  {
    switch(state){
      case state_prolog:
        t = (node_time_map_prolog.find(id))->second;
        break;
      case state_kernel:
        t = (node_time_map_kernel.find(id))->second;
        break;
      case state_epilog_start:
        t = (node_time_map_kernel.find(id))->second;
        break;
      case state_epilog: 
        t = (node_time_map_epilog.find(id))->second;
        break;
      default: break;
   }
  }

  return t;
}

//returns whether the operations are mapped more than a cycle apart or not
bool isMappedMoreThanACycleApart(int node1,int node2,exec_state state)
{
  int t1 = getMappedTime(node1,state);
  int t2 = getMappedTime(node2,state);
  if(state == state_kernel)
  {
 //   printf("\nII = %d\tMappedCycleApart\n",II); 
 //   printf("\nDifference is %d\n",abs(t1-t2));  
    /*
     * We dont need this now as we use only phi nodes. 
     * Else it should check whether node 1 and node 2 are phi nodes or not. If not then return false for diff + 1 == II
     */      
    /*if((abs(t1-t2)+1) == II)	
      return false;*/
  } 
  return (abs(t1-t2) > 1);
}

int getLiveVarData(int nodeID)
{
  std::vector<int> operands = getOperands(nodeID);	//get Operands of LiveVar St_Data Node
  int st_add = nodeID - 1; 
  int livevar_data;
  /*
   * We first search that whether the st_add has any operands. 
   * If yes, then st_data should have one operand has st_add and other as node providing live data value
   * Else, We see that which operand is either constant/phi node and choose it as address node and choose remaining operand as data node providing live var.
   */
/*
  std::vector<int> add_operands = getOperands(nodeID);
  if(add_operands.size() > 0)
  {
	if(operands[0] == st_add)
		livevar_data = operands[1];
        else
		livevar_data = operands[0];
	return livevar_data;
  }
  else
  {
	for(int i=0; i < operands.size(); i++)
	
  }
*/
  for(std::vector<int>::iterator it = operands.begin(); it!= operands.end(); ++it)
  {
        string nodename = getNodeName(*it);
        if(((getNodeType(*it) != st_add) && (getNodeType(*it) != constant)) || (nodename.find("Const") != string::npos)) //|| (getNodeType(*it) != cgra_select)))
          livevar_data = *it;
  }

  return livevar_data;	
}


/* getArrayAddress(pe, addr, id) 
1. checks whether a given id (id = getNodeType(node)) is a llvm_route node. 
2. If yes then the program is accessing a[i] numbers so we need to generate address for a[i] terms. 4*i for int variable. Also we need to find the limiting value until which the address needs to be calculated (limiting_value)  TODO for other variable type. 
3. else it is accessing only one address say a[2]. Then we need to get the value 2 by iterating through the nodes and finding the constant value and generate its address. 
4. By reading through this file it will be more clear as to what is being done to generate array address. */


void getArrayAddress(int pe, int addr, int node, int reg_num, int maxMemoryOperations, int num_mem_ops)
{

 //int limit = extractnumber_from_const(2,30);  
  //ArrayOperations++;  
 
  int LDi_imm, LDMi_imm, LDUi_imm;
  int id; 
  string nodename;

//update size_array
//  int size_array = extractlimit_from_node(2); 
 
  std::multimap<int, int>::iterator it = in_edge.find(node);
  vector<int> operands = getOperands(it->second); 
  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret; 
  ret = in_edge.equal_range(it->second);
   for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
  {
     id = getNodeType(it2->second);
     nodename = getNodeName(it2->second);
    break; 
  }  
    if( (id == Mult) & (nodename.find("idxprom") != string::npos) )   //getArrayAddress
    {    
     //   int operand1 = operands[2]; 

	int addr_array = addr;  
         
	  printf("\n%x\t",addr_array);
         cout<<node<<"\t"<<pe<<"\t"<<addr_array<<"\t"<<reg_num<<endl;

          LDi_imm = addr_array & 0x00000fff;
          LDMi_imm = (addr_array & 0x00fff000) >> 12;
   	  LDUi_imm = (addr_array & 0xff00000) >> 24;


    	CGRA_Instruction LDi_ins(LDi,0,Immediate,Register,0,0,reg_num,1,LDi_imm,0,0);
    	CGRA_Instruction LDMi_ins(LDMi,0,Immediate,Register,0,0,reg_num,1,LDMi_imm,0,0);
    	CGRA_Instruction LDUi_ins(LDUi,0,Immediate,Register,0,0,reg_num,1,LDUi_imm,0,0);

    	unsigned int dec1= LDi_ins.DecodeInstruction(&LDi_ins),dec2 = LDMi_ins.DecodeInstruction(&LDMi_ins), dec3 = LDUi_ins.DecodeInstruction(&LDUi_ins);

    	printf("%x: %x: %x ",dec1,dec2,dec3);

    	std::vector<CGRA_Instruction> ins_set;
    	ins_set.push_back(LDi_ins);
    	ins_set.push_back(LDMi_ins);
    	ins_set.push_back(LDUi_ins);

 	initInstructions.insert(std::pair<int,std::vector<CGRA_Instruction> >(pe,ins_set));
	  //addr_array += (4);
	
	// update maxmemory operation count
        //maxArrayMem++;
        
    } 
    else 
    {
	printf("\n%x\t",addr);
	int value; 
         cout<<node<<"\t"<<pe<<"\t"<<addr<<"\t"<<reg_num<<endl;
	for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
	{
	  int node_id = it2->second; //extractNumber_from_Const @TODO for incoming edges for statement
	  std::map<int, string>::iterator nameit = nodeid_names.find(node_id);
	  value = extractNumber(nameit->second); 
	} 
	//int value = extractnumber_from_const(id) 
 	
         int addr_array= addr+(4*value); //getElementAddress

 	//update maxmemory operation count
          maxMemoryOperations = ((num_mem_ops+1) > maxMemoryOperations)? (num_mem_ops+1):maxMemoryOperations;

         int LDi_imm = addr_array & 0x00000fff;
         int LDMi_imm = (addr_array & 0x00fff000) >> 12;
         int LDUi_imm = (addr_array & 0xff00000) >> 24;


        CGRA_Instruction LDi_ins(LDi,0,Immediate,Register,0,0,reg_num,1,LDi_imm,0,0);
        CGRA_Instruction LDMi_ins(LDMi,0,Immediate,Register,0,0,reg_num,1,LDMi_imm,0,0);
        CGRA_Instruction LDUi_ins(LDUi,0,Immediate,Register,0,0,reg_num,1,LDUi_imm,0,0);

        unsigned int dec1= LDi_ins.DecodeInstruction(&LDi_ins),dec2 = LDMi_ins.DecodeInstruction(&LDMi_ins), dec3 = LDUi_ins.DecodeInstruction(&LDUi_ins);

        printf("%x: %x: %x ",dec1,dec2,dec3);

        std::vector<CGRA_Instruction> ins_set;
        ins_set.push_back(LDi_ins);
        ins_set.push_back(LDMi_ins);
        ins_set.push_back(LDUi_ins);

        initInstructions.insert(std::pair<int,std::vector<CGRA_Instruction> >(pe,ins_set));
    
       }
   
}	
	 

//read the symbol table from obj, get the address of var and print it
void printvalue(string var,string obj)
{

  FILE *pipe;
  char result[80];
  string command;


  command = "/home/shail/CGRA/toolchain/othertools/scripts/getaddress.sh";
  command += obj + " " + var;

  if (( pipe = popen(command.c_str(), "r")) == NULL)
  {
    perror("popen");
    exit(1);
  }

  fgets(result,80,pipe);

  pclose(pipe);

  int* addr=(int*)strtol(result,NULL,16);

  printf("Address is %x\n",*addr);

}

//get the operation type of the node
/*int getNodeType(int id)
{
  std::map<int, int>::iterator it = nodeid_type.find(id);
  return it->second;
}*/

//get the node id for the source operation of this routing node
int getRouteSrc(int id)
{
  std::multimap<int, int>::iterator it = in_edge.find(id);
  if(getNodeType(it->second) != route)
    return it->second;
  else
    getRouteSrc(it->second);
}

/*
 *this function is responsible to update the operand orders by incorporating the routing nodes generated by RegiMAP
 */

void updateOperandOrder()
{
  /*Steps:
   * get all routing nodes.
   * for each routing node, get all the outgoing edges
   *  for each outgoing edge, get the operand order from the source of this
   *  routing node to the destination of the edge.
   *  update the operand order map with 
   */

  for(int i=0;i<routingNodes.size();++i)
  {
    int node = routingNodes[i];
    int src = getRouteSrc(node);

    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = out_edge.equal_range(node);
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
      //edge from route to dest
      std::pair<int,int> edge1(node,it->second);

      //edge from src to dest
      std::pair<int,int> edge2(src,it->second);
      int operandOrder = operand_order_map[edge2];

      operand_order_map.insert(std::pair< std::pair<int,int>,int >(edge1,operandOrder));

    }      

  }
}

/*
   return the node id's of operands in the order of their appearance in the instruction
   */

/*std::vector<int> getOperands(int nodeID)
{
  std::vector<int> result;
  //we cant have more than 3 operands
  int temp[3];

  int nodeType = getNodeType(nodeID);
  if(nodeType != st_data && nodeType != ld_data)
  {
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = in_edge.equal_range(nodeID);
    int ctr = 0;
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
      std::pair<int,int> edge(it->second,nodeID);
      if(operand_order_map.count(edge) > 0)
      {
        temp[operand_order_map[edge]] = it->second;
        ctr++;
      }
    }

    for(int j =0;j<ctr;j++)
      result.push_back(temp[j]);
  }
  else
  {
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = in_edge.equal_range(nodeID);
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
        result.push_back(it->second);
    }
  }

  return result;

}*/

OPCode getOpCode(int nodeID)
{
  int type = getNodeType(nodeID);
  OPCode opcode;
  switch(type)
  {
    case add:
      opcode = Add;
      break;
    case sub: 
      opcode = Sub;
      break;
    case mult: 
    case llvm_route: 
      opcode = Mult;
      break;
    case regi_div:
      opcode = NOOP;
      break;
    case shiftl:
      opcode = cgraASL;
      break;
    case shiftr:
      opcode = cgraASR;
      break;
    case andop:
      opcode = AND;
      break;
    case orop:
      opcode = OR;
      break;
    case xorop:
      opcode = XOR;
      break;
    case cmpUGT:
    case cmpUGEQ:
    case cmpSGEQ:
    case cmpSGT:
      opcode = GT;
      break;

    case cmpEQ:
      opcode = EQ;
      break;
    case cmpNEQ:
      opcode = NEQ;
      break;
    case cmpULT:
    case cmpULEQ:
    case cmpSLEQ:
    case cmpSLT:
      opcode = LT;
      break;
    case ld_add:
    case ld_data:
    case st_data:
    case st_add:
      opcode = Add;
      break;
    case route:
      opcode = Add;
      break;
    case cgra_select:
      opcode = Add;
      break;
    default: opcode=NOOP;
             break;



             
              /*  ld_add_cond,
                ld_data_cond,
                st_add_cond,
                st_data_cond,
                llvm_route,
                cgra_select,
                constant,
                loopctrl,
                rest*/

  }

  return opcode;

}


//TODO 
int getPredic(int nodeID)
{
  /*
     no info on this as of now
     returning 0
     */
  return 0;

}


//returns where the 1st operand of this instruction is going to come from
PEInputMux getLMuxSelector(int nodeID, exec_state state)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add
   result = REGISTER

   if the instruction is a ld_data
   result = DATABUS

   if the instruction is st_data
   {
   get the node id of the operand other than the varname and st_add
   if they are scheduled more than a cycle apart
   {
   result = REGISTER
   }
   else
   result = Relative PE position of the operand to the PE this node is mapped on
   }



   ***************Alu Operations**************
   Get the first operand (lets call it op)
   If(op is Constant)
   result = IMMEDIATE
   if(op is scheduled more than 1 cycle apart)
   result = REGISTER
   else
   result = Relative PE position of the operand to the PE this node is mapped on

   *****************Route Operation************
   get the nodeID of the src node in the edge in which this is the destination
   if they are scheduled more than a cycle apart
   result = REGISTER
   else
   result = Relative position of the PE of the src node to the PE this node is mapped to
   */

  PEInputMux result = Register;
  int nodetype = getNodeType(nodeID);
  vector<int> operands = getOperands(nodeID);
  int pe1,pe2;

  //there will be atmost 1 incoming edge to the routing node
  std::multimap<int, int>::iterator it_inedge = in_edge.find(nodeID);
  //MEMORY OPERATIONS
  switch(nodetype){

    case ld_add:
    case st_add:
      return result;
      break;
    case ld_data:
      result = DataBus;
      return result;
      break;
    case st_data:
      int operandID;
      for(std::vector<int>::iterator it = operands.begin(); it!= operands.end(); ++it)
      {
	string nodename = getNodeName(*it);
        if(((getNodeType(*it) != st_add) && (getNodeType(*it) != constant)) || (nodename.find("Const") != string::npos))
          operandID = *it;
      }
      if(getNodeType(operandID) == constant)
      {
    	      result = Register;
      	      return result;
	      break;
      }
      if(isScheduledMoreThanACycleApart(nodeID,operandID))
      {
        nodesThatReadRotatingRF.insert(nodeID);
        result = Register;
      }
      else
      {
        if(isLiveStoreNode(nodeID))
	  pe1 = getLiveVarMappedPE(nodeID);
        else
          pe1 = getMappedPE(nodeID,state);	

        pe2 = getMappedPE(operandID,state);
        result = getRelativePosition(pe1,pe2);	
      }
      return result;
      break;
      //ROUTING NODE
    case route:
    case llvm_route: 
      if(isScheduledMoreThanACycleApart(nodeID,it_inedge->second))
      {
        nodesThatReadRotatingRF.insert(nodeID);
        result = Register;
      }
      else
      {
        pe1 = getMappedPE(nodeID,state);	
        pe2 = getMappedPE(it_inedge->second,state);
        result = getRelativePosition(pe1,pe2);	
      }
      return result;
      break;
case cgra_select:
      /*
       * Currently Phi Nodes Are Only Implemented As Selct Nodes.
       * For Control Flow Implementation, We Will have 3 operands - 1. Condition 2. Op1 3. Op2
       * In that case, we will assign condition value to operand 0. And current operand 2 and 3 for phi nodes
       * Will be used correspondingly. So, additional conditions to imply for if-then-else implementation
       */
    {
      	int operand1, operand2, selected;
        int dependence_distance = getDepenDistance(nodeID);
//        int sel_counter = getSelCounter(nodeID);
//        bool condition;

	/*
	 * There can be case where both operands are involved to mapped node with recurrence edge of some weight
  	 * Usually, One of the operand should be regular true dependency with dependence weight 0. 
 	 * Only that case is targeted here for following code. 
	 * Otherwise, dependence_distance and operands should be selected correspondingly.
	 */

//        if(dependence_distance > 0)
  //      {

/*            if(sel_counter >= dependence_distance)
            {
                std::map<int,bool>::iterator it = select_node_condition.find(nodeID);
                it->second = 0;
            }
            else
            {
                std::map<int,int>::iterator it = select_node_counter.find(nodeID);
                it->second = sel_counter + 1;
            }
*/
	    if(operands.size() > 1)
	    {
	    	if(getNodeType(operands[0]) == constant)
	    	{
		    	operand1 = operands[0]; //Initial Value
		    	operand2 = operands[1]; //Loop-carried value
		}
		else
		{
			operand1 = operands[1]; //Initial Value
		    	operand2 = operands[0]; //Loop-carried value
		}
	    }
	    else
			operand2 = operands[0];

            //cout << "Operands: " << operands[0] << "\t" << operands[1] << endl;
	    if(operands.size() > 1) {
        	std::map<int,int>::iterator it1 = select_constant_node_result.find(nodeID);
            it1->second = operand1; }

//        	std::map<int,int>::iterator it2 = select_phi_node_result.find(nodeID);
//            it2->second = operand2;

  //          condition = getSelCondition(nodeID);

    //    }
    /*    else
        {
            condition = operands[0];
            operand1 = operands[1];
            operand2 = operands[2];
        }
*/
/*    	if(condition == 1) 
        {
	      selected = operand1;
        }
        else
        {
	      selected = operand2;
        } 
*/
//	std::map<int,int>::iterator it = select_node_result.find(nodeID);
//    it->second = selected;

  //      cout << "\n Node: " << nodeID << "\tCondition = " << condition << "\tOperand1: " << operand1 << "\tOperand2: " << operand2 << "\tCounter: " << sel_counter << "\tDepen_Distance: " << dependence_distance << "\tResult: " << selected << "\n";

	/* Now treat like other cases - add/route etc.
	 * If operand is constant, result is immediate
	 * Otherwise, check whether it is scheduled more than a cycle apart or not and give relevant position of PE or return register
	 */

	//operand = selected;

	int opType_initial = getNodeType(operand1);
    PEInputMux initial_result = Register;

 //   if(opType_initial == constant)  //It will be constant mostly for phi nodes
   //     {
    	      initial_result = Immediate;
    //	}
    /*                                                         
    if(isScheduledMoreThanACycleApart(nodeID,operand1))     
    {                                                       
          nodesThatReadRotatingRF.insert(nodeID);           
          initial_result = Register;                                                                  
    }                                                       
    else                                                    
    {                                                       
      	      pe1 = getMappedPE(nodeID,state);	        
              pe2 = getMappedPE(operand1,state);            
              initial_result = getRelativePosition(pe1,pe2);	                                    
    }                                                       		                                      
   */ 
    setlmuxphi(nodeID, initial_result);
        
    int opType = getNodeType(operand2);
    
	if(opType == constant)
        {
    	      result = Immediate;
      	      return result;
    	}

 
	if(isMappedMoreThanACycleApart(nodeID, operand2, state_kernel)) //If operand2 is mapped a cycle apart than phi node
	{
              //cout << nodeID << "is mapeped more than a cycle apart." << endl;  
	      nodesThatReadRotatingRF.insert(nodeID);
	      result = Register;
	      return result;
  	}
	else
	{
      	      pe1 = getMappedPE(nodeID,state);	
              pe2 = getMappedPE(operand2,state);
              result = getRelativePosition(pe1,pe2);	
              return result;
	}

    	return result;
        break;		
    }
    default:
      break;						

  }

  //ALU Operations 
  if(operands.size() > 0)
  {
    int operand1 = it_inedge->second;
    int opType = getNodeType(operand1);
    if(opType == constant)
    {
      result = Immediate;
      return result;
    }
	
    if(isScheduledMoreThanACycleApart(nodeID,operand1))
    {
      nodesThatReadRotatingRF.insert(nodeID);
      result = Register;
      return result;
    }
    else
    {
      pe1 = getMappedPE(nodeID,state);	
      pe2 = getMappedPE(operand1,state);
      result = getRelativePosition(pe1,pe2);	
      return result;
    }

  }

}

//returns where the 2nd operand if this instruction is going to come from
PEInputMux getRMuxSelector(int nodeID,exec_state state)
{
  /*
   ************Memory Operations*******************
   if the instruction is ld_add, st_add
   {
   get all the operands of this node
   if(no operands)
   result = IMMEDIATE (set to 0)
   else
   {
   there will be atmost 1 operand for this instruction
   if the operand is constant
   result = IMMEDIATE (set to the constant value)
   if(the operand is scheduled more than a cycle apart)
   result = REGISTER
   else
   result =  Relative PE position of the operand to the PE this node is mapped on
   }
   }

   if the instruction is a ld_data
   result = immediate  (set immediate to 0)

   if the instruction is st_data
   result = immediate  (set immediate to 0)

   ***************Alu Operations**************
   Get the second operand (lets call it op)
   If(op is Constant)
   result = IMMEDIATE
   if(op is scheduled more than 1 cycle apart)
   result = REGISTER
   else
   result = Relative PE position of the operand to the PE this node is mapped on

   *****************Route Operation************
   result = Immediate (set to 0)

*/
  PEInputMux result = Register;
  int nodetype = getNodeType(nodeID);
  vector<int> operands = getOperands(nodeID);
  int pe1,pe2;

  switch(nodetype){
    //ROUTING NODE
    case route:
    case llvm_route:
      //MEMORY OPERATIONS
    case ld_data:
    case st_data:
      result = Immediate;
      return result;
      break;
    case ld_add:
    case st_add:
      if(operands.size() == 0)
      {
        result = Immediate;
        return result;
      }
      else
      {
        int operand1 = operands[0];
        int opType = getNodeType(operand1);
        if((opType == constant))  //|| (opType == cgra_select))
        {
          result = Immediate;
          return result;
        }
        if(isScheduledMoreThanACycleApart(nodeID,operand1))
        {
          nodesThatReadRotatingRF.insert(nodeID);
          result = Register;
          return result;
        }
        else
        {
          if(isLiveStoreNode(nodeID))
            pe1 = getLiveVarMappedPE(nodeID);	
          else
            pe1 = getMappedPE(nodeID,state);

	  //FixMe: Make Provision For Operand Providing Store Address, Which Is Not Mapped As Part Of Kernel
          /*if(isLiveNode(operand1))
            pe2 = getLiveVarMappedPE(operand1);	
          else*/

          pe2 = getMappedPE(operand1,state);
          result = getRelativePosition(pe1,pe2);	
          return result;
        }
      }

      break;
/*
    case st_add: 
	if(operands.size() == 0)
      {
        result = Immediate;
        return result;
      }
      else
      {
	int operand1; 
	std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
        ret = in_edge.equal_range(nodeID);
	for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
	{
	 operand1 = it->second;
	}
        int opType = getNodeType(operand1);
        if(opType == constant)
        {
          result = Immediate;
           return result; 
	}
        if(isScheduledMoreThanACycleApart(nodeID,operand1))
        {
          nodesThatReadRotatingRF.insert(nodeID);
          result = Register;
          return result;
        }
        else
        {
          pe1 = getMappedPE(nodeID,state);
          pe2 = getMappedPE(operand1,state);
          result = getRelativePosition(pe1,pe2);
          return result;
        }
      }

      break;*/
    case cgra_select:	//Immediate Value For Select Will Be Provided Through Left Mux Only If Selected Node Is Constant
      setrmuxphi(nodeID, Register); //For Initial Values This Should Be zero, So register 0 which will be zero initially
      result = Immediate;   //For loop-carried value, Lmux = loop carried value, rumx = 0
	return result;  //It will be register 0
	break;
    default:
      break;						

  }

  //cout << operands.size() << "\n";
  //cout << "Operand1: " << operands[0] << "\tOperand2: " << operands[1] << "\n";
  //ALU Operations 
  if(operands.size() > 1)
  {
    int operand2 = operands[1];
    int opType = getNodeType(operand2);
    //cout << "NodeID: " << nodeID << "\tOperand2: " << operand2 << "\n";	
    if(opType == constant)
    {
      result = Immediate;
      return result;
    }

    if(isScheduledMoreThanACycleApart(nodeID,operand2))
    {
      nodesThatReadRotatingRF.insert(nodeID);
      result = Register;
      return result;
    }
    else
    {
      pe1 = getMappedPE(nodeID,state);	
      pe2 = getMappedPE(operand2,state);
      result = getRelativePosition(pe1,pe2);	
      return result;
    }

  }

}

//this function is responsible for returning the register number a node writes
//to
int getOutputRegisterNumber(int node)
{
  int result=-1;
  if(node_Output_Register.count(node) > 0)
    result = (node_Output_Register.find(node))->second;

  return result;
}


//This function accepts the register number to which the src node writes to,
//computes the distance between the src and dest instruction and returns the
//register number the dest node should read from
//THE RF ROTATES TO THE LEFT
//0 1 2 3
//3 0 1 2
//2 3 0 1 
//1 2 3 0
//0 1 2 3
int getRotatingRegNum(int regNum,int src,int dest, exec_state state)
{

  int Tsrc,Tdest;

  Tsrc = getScheduledTime(src);
  Tdest = getScheduledTime(dest);

  int diff = abs(Tsrc - Tdest);
  int srcMappedTime = getMappedTime(src,state);
  int destMappedTime = getMappedTime(dest,state);
  cout << src << "\t" << srcMappedTime << "\t" << dest << "\t" << destMappedTime << endl;
  int distance; //Distance To be fixed and checked

  /*
     1. diff <II
     src mapped b4 dest
     return same number
     src mapped after dest
     return number corresponding to 1 rotation
     2. diff >= II
     dist = floor(diff/II)
     src mapped b4 dest
     return number corresponding to dist rotation
     dest mapped b4 src
     return number corresponding to dist+11 rotation

*/
  if(diff >= kernel_II)
      II = kernel_II;
  
  if(diff < II)
  { 
    if(srcMappedTime < destMappedTime)
    {
      return regNum;
    }
    else
    {
      distance = 1;
      return (regNum+(REGFILESIZE-distance))%REGFILESIZE;
    }
  }
  else
  {
    distance = floor(diff/II); 
    if(srcMappedTime < destMappedTime)
    {
      return (regNum+(REGFILESIZE-distance))%REGFILESIZE;
    }
    else
    {
      ++distance;
      return (regNum+(REGFILESIZE-distance))%REGFILESIZE;
    }
  }
}



//This function is responsible for returning the register number that will act
//as operand 1
int getReg1Address(int nodeID,PEInputMux LMux,exec_state state)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add
   result = register number this node is mapped to in mem_node_regNum

   if the instruction is a ld_data
   result = 0

   if the instruction is st_data
   {
   get the node id of the operand other than the varname and st_add
   if they are scheduled more than a cycle apart
   {
   reg=get the register that operand writes to
   result = getRotatingRegNum(reg,operandID,nodeID);
   }
   else
   result = 0
   }
   ***************Alu Operations**************
   Get the first operand (lets call it op)
   If(op is Constant)
   result = 0
   if(op is scheduled more than 1 cycle apart)
   reg=get the register that operand writes to
   result = getRotatingRegNum(reg,operandID,nodeID);
   else
   result =0

   *****************Route Operation************
   get the source node of the only incoming edge to this node
   if(src node is scheduled more than 1 cycle apart)
   reg=get the register that operand writes to
   result = getRotatingRegNum(reg,operandID,nodeID);
   else
   result =0

   *****************Select Operation************
   Follow Like Routing As We will Have Selected Node As Operand Part of Input Edge
   We will come here only if we require loop-carried value from register in case of phi
   We will come here if selected source node has value in register in case of if-then-else
 	
*/
  int result = 0;
  if(LMux == Register)
  {
    int opType = getNodeType(nodeID);

    //there will be atmost 1 incoming edge to the routing node
    std::multimap<int, int>::iterator it_inedge = in_edge.find(nodeID);
    vector<int> operands = getOperands(nodeID);

    switch(opType){
      //MEMORY OPERATIONS
      case ld_add:
      case st_add:
        result = mem_node_regNum[nodeID];
        return result;
        break; 
      case ld_data:
        result = 0;
        return result;
        break;
      case st_data:
        int op;
        for(int i=0;i<operands.size();++i)
        {
          int type = getNodeType(operands[i]);
	  string nodename = getNodeName(operands[i]);
          if((type!=constant && type!=st_add) || (nodename.find("Const") != string::npos))
          {
            op = operands[i];
            break;
          }    
        }
	if(getNodeType(op) == constant)
        {
	  result = 0;
	  return result;
	  break;
        }	
        if(isScheduledMoreThanACycleApart(nodeID,op))
        {
          int srcReg = getOutputRegisterNumber(op);
          result = getRotatingRegNum(srcReg,op,nodeID,state);
          return result;
  	  break;
        }
        else
        {
          result = 0;	
          return result;
   	  break;
        } 
        //ROUTING NODE        
      case route:
      case llvm_route:
        if(isScheduledMoreThanACycleApart(nodeID,it_inedge->second))
        {
          int srcReg = getOutputRegisterNumber(it_inedge->second);
          result = getRotatingRegNum(srcReg,it_inedge->second,nodeID,state);
        }
        else
        {
          result = 0;
        }
        return result;
        break;
      case cgra_select:
      {
	int srcoperand = getSelectedPhiNode(nodeID);
	//cout << "\nNode: " << nodeID << "\tSelected Phi Node is: " << srcoperand;
        if(isMappedMoreThanACycleApart(nodeID,srcoperand, state_kernel))
        {
          int srcReg = getOutputRegisterNumber(srcoperand);
          result = getRotatingRegNum(srcReg,srcoperand,nodeID,state);
        }
        else
        {
          result = 0;
        }
        return result;
        break;
      }

    }
    /*   ***************Alu Operations**************
         Get the first operand (lets call it op)
         If(op is Constant)
         result = 0
         if(op is scheduled more than 1 cycle apart)
         reg=get the register that operand writes to
         result = getRotatingRegNum(reg,operandID,nodeID);
         else
         result =0
         */
    if(operands.size() > 0)
    {
      int op1 = operands[0];
      int opType = getNodeType(op1);
      if(opType == constant)
        result == 0;

      if(isScheduledMoreThanACycleApart(nodeID,op1))
      {
        int srcReg = getOutputRegisterNumber(op1);
        result = getRotatingRegNum(srcReg,op1,nodeID,state);
      }
      else
      {
        result = 0;
      }

      return result;
    }

  }
  else
  {
    return 0;
  }

}


int getReg2Address(int nodeID,PEInputMux RMux,exec_state state)
{
  /*
   ************Memory Operations*******************
   if the instruction is ld_add, st_add
   {
   get all the operands of this node
   if(no operands)
   result = 0
   else
   {
   there will be atmost 1 operand for this instruction
   if the operand is constant
   result = 0
   if(the operand is scheduled more than a cycle apart)
   {
   reg = getSourceRegNum(operand)
   result = getRotatingRegNum(reg,operandID,nodeID)
   }
   else
   result = 0
   }
   }

   if the instruction is a ld_data
   result = 0

   if the instruction is st_data
   result = 0

   ***************Alu Operations**************
   Get the second operand (lets call it op)
   If(op is Constant)
   result = 0
   if(op is scheduled more than 1 cycle apart)
   {
   reg = getSourceRegNum(operand)
   result = getRotatingRegNum(reg,operandID,nodeID)
   }

   else
   result = 0

   *****************Route Operation************
   result = 0

*/
  if(RMux == Register)
  {
    int result = 0;
    std::multimap<int, int>::iterator it_inedge = in_edge.find(nodeID);
    int nodetype = getNodeType(nodeID);
    vector<int> operands = getOperands(nodeID);
    int pe1,pe2;

    switch(nodetype){
      //ROUTING NODE
      case route:
      case llvm_route:
      case cgra_select:		//RMux Is Not Used In Case Of Phi/Select Nodes
        //MEMORY OPERATIONS
      case ld_data:
      case st_data:
        result = 0;
        return result;
        break;
      case ld_add:
      case st_add:
        if(operands.size() == 0)
        {
          result = 0;
          return result;
        }
        else
        {
          int operand1 = it_inedge->second;
          int opType = getNodeType(operand1);
          if(opType == constant)
          {
            result = 0;
            return result;
          }
          /*if(isScheduledMoreThanACycleApart(nodeID,operand1))
          {
            int srcreg = getOutputRegisterNumber(operand1);
            result = getRotatingRegNum(srcreg,operand1,nodeID,state);
            return result;
          }
          else
          {
            result = 0;	
            return result;
          }
        }

        break;*/
            //result = mem_node_regNum[nodeID];
            //printf("\nNodeID: %d\tRegNum: %d\n",nodeID,result);
            //int op = it_inedge->second; //operands[0];
            int t1 = getScheduledTime(nodeID); 
            int t2 = getScheduledTime(operand1);
            int diff = abs(t1-t2);
            //printf("\nt1 = %d\tt2 = %d\tdiff = %d\n",t1,t2,abs(t1-t2));
            int II_distance = floor(diff/kernel_II);
            //printf("\nII = %d\tdiff = %d\tII_distance = %d\n",kernel_II,diff,II_distance);
        
            if(II_distance > 0) //isScheduledMoreThanIICycleApart(nodeID,op))
            {
                //printf("\nScheduled %d II cycles apart.\n",II_distance);  
                int srcReg = getOutputRegisterNumber(operand1);
                result = getRotatingRegNum(srcReg,operand1,nodeID,state);
                return result;
            }
            else
            {
                result = 0; //mem_node_regNum[nodeID];
                return result;
            }
        break;
          }
      default:
        break;						

    }

    //ALU Operations 
    if(operands.size() > 1)
    {
      int operand2 = operands[1];
      int opType = getNodeType(operand2);
      if(opType == constant)
      {
        result = 0;
        return result;
      }

      if(isScheduledMoreThanACycleApart(nodeID,operand2))
      {
        int srcreg = getOutputRegisterNumber(operand2);
        result = getRotatingRegNum(srcreg,operand2,nodeID,state);
        return result;
      }
      else
      {
        result = 0;	
        return result;
      }
    }
  }
  else
    return 0;
}

//TODO what if there are multiple dependents of the same operation and they use
//the register we are going to release
//this function releases registers consumed by this node and updates the
//<pe,freeRegisters> map
void releaseRegisters(int nodeID,exec_state state)
{
  /*
     check if this register reads from the Rotating RF
     get the operands for this instruction
     for each operand 
     if it writes to registers, get the reg num it writes to and the pe it is mapped to
     add that reg num to the free regs list of this pe

*/
  if(nodesThatReadRotatingRF.count(nodeID) > 0)
  {
    vector<int> operands = getOperands(nodeID);
    for(int i=0;i<operands.size();++i)
    {
      int op = operands[i];
      int regNum = getOutputRegisterNumber(op);

      if(regNum != -1)
      {
        int pe = getMappedPE(op,state);
        std::set<int> regs = pe_free_registers[pe];
        regs.insert(regNum);
        pe_free_registers[pe] = regs;
      }

    }
  }
}

//gives a free register for this PE and updates the map storing the free PE list
int getFreeRegister(int pe)
{
  std::set<int> freeRegs = pe_free_registers[pe];
  if(!freeRegs.empty())
  {
    int result = *freeRegs.begin();
    freeRegs.erase(freeRegs.begin());
    pe_free_registers[pe] = freeRegs;
    return result;
  }
  else
    return -1;
}




//This function is responsible for returning the register number this node is
//supposed to write to
int getWriteRegAddress(int nodeID,exec_state state)
{
  /*
   ***************Alu Operations, ld_data and Routing operations**************
   get the pe this node is mapped to
   get a free register from it
   return that

*/
  int pe = getMappedPE(nodeID,state);
  return getFreeRegister(pe);
}

bool isWriteEnabled(int nodeID)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add, st_data
   result = false

   ***************Alu Operations ld_data and ROUTE OPERATION**************
   {
   get the outgoing edges where this node is the source
   if any of the destination instructions are scheduled more than a cycle apart
   result = true
   else
   result = false
   }

*/
  bool result = false;
  int opType = getNodeType(nodeID);
  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
  //MEMORY OPERATIONS
  switch(opType){
    case ld_add:
    case st_add:
    case st_data:
      return false;
      break;
    default:
      break;
  }
  //ALU OPERATIONS,ld_data and route

  ret = out_edge.equal_range(nodeID);
  for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
  {

    if(isScheduledMoreThanACycleApart(nodeID,it->second))
    {
      result = true;
      break;
    }

    int phinode = getPhiNode(nodeID);
    if(phinode != -1) 
    {
    	if(isMappedMoreThanACycleApart(nodeID,getPhiNode(nodeID), state_kernel))
    	{
	        //cout << "\nNode: " << nodeID << "\tPhi Node: " << phinode << "\n";
		result = true;
		break;
    	}
    }
  }
  return result;
}

//return the immediate value to be used for the instruction for this node
int getImmediate(int nodeID)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add
   {
   get operands
   if(no operands)
   result = 0
   else
   result = number extracted from the node name
   }

   if the instruction is a ld_data,st_data
   result = 0

   ***************Alu Operations**************
   get operands
   get the node id of the operand with operation_type = constant
   get the name of the node
   result = extract the immediate field from this name
   *****************Route Operation************
   result = 0

*/


  int result = 0;

  vector<int> operands = getOperands(nodeID);
  int nodetype = getNodeType(nodeID);
  switch(nodetype){
    //MEMORY OPERATIONS
    case ld_data:
      //ROUTING NODE
    case route:
      return result;
      break;	
    case st_data:
      {
      if(isLiveStoreNode(nodeID))
      {
      	if(operands.size() == 0)
      	{
          result = 0;
          return result;
	  break;
      	}
      	else
      	{
          for(int i=0;i<operands.size();++i)
          {
            string nodename = getNodeName(operands[i]);
            if((getNodeType(operands[i]) == constant) && (nodename.find("Const") != string::npos))
            {
              result = extractNumber(nodeid_names.find(operands[i])->second);
              return result;
       	      break;
            }
          }
        }
      }
      return result; 	
      break;
      }
    case ld_add:
    case st_add:
      if(operands.size() == 0)
      {
        result = 0;
        return result;
	break;
      }
      else
      {
        for(int i=0;i<operands.size();++i)
        {
          if(getNodeType(operands[i]) == constant)
          {
            result = extractNumber(nodeid_names.find(operands[i])->second);
            return result;
       	    break;
          }
        }
      }
	break;
    case cgra_select:
      {
      /*
       * Probably implementing if-then-else will not require any immediate value as input on right bus.
       * As all operands for if-then-else will be value from some PE. 
       * Anyways, if selected operand is constant then it is value of that constant. else 0.
       * For phi nodes, it is again, if operand is constant immediate is that value. Else 0.
       * So, Left Mux which is doing this selection between operands should get value of that operand and provide here.
       */

	int selected_node = getSelectedConstantNode(nodeID);    //Selected constant node

//	if(getNodeType(selected_node) == constant) 
//	{
		if(operands.size() < 2)	result = 0;
		else
		{
			std::map<int, string>::iterator it = nodeid_names.find(selected_node);
			string node_name = it->second;
			result = extractNumber(node_name);
		}
        setimmediatephi(nodeID, result);
//	}
//	else
		result = 0; //Result = 0 for loop carried nodes
	return result;	
	break;
	}
    default:
      break;
  }

  //ALU OPs
  if(operands.size() == 0)
  {
    result = 0;
    return result;
  }
  else
  {
    for(int i=0;i<operands.size();++i)
    {
      if(getNodeType(operands[i]) == constant)
      {
        result = extractNumber(nodeid_names.find(operands[i])->second);
        return result;
      }
    }
  }

  return result;
}

//return true this instruction needs to assert the address bus
bool isAddressBusAssert(int nodeID)
{
  /*
     if the instruction is ld_add,st_add
     result = true
     else 
     result = false
     */
  bool result = false;
  int nodetype = getNodeType(nodeID);
  if(nodetype == ld_add || nodetype == st_add)
    result = true;

  return result;
}

//return true this instruction needs to assert the data bus
bool isDataBusAssert(int nodeID)
{
  /*
     if the instruction is st_data 

     result = true
     else 
     result = false
     */
  bool result = false;
  if(getNodeType(nodeID) == st_data)
    result = true;	

  return result;
}


//get the name of the variable to be loaded (this function is called for a ld_add operation)
string getloadvarname(int id)
{
  /*
     a ld_add node has only one outgoing edge (dest).
     dest will have 2 incoming edges. One from ld_add and the other node indicating the variable name
     */

  std::multimap<int, int>::iterator it1 = in_edge.find(id);
  int loadid;  	

 if ( it1->second == 0) 
  { 
  std::multimap<int, int>::iterator it = out_edge.find(id);
  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
  ret = in_edge.equal_range(it->second);
  for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
  {
    if(it2->second != id)
    {
      loadid=it2->second;
    }
  }
 }

else {

std::multimap<int, int>::iterator it = in_edge.find(id);
  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
  ret = in_edge.equal_range(it->second);
   for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
  { 
    if( getNodeType(it2->second) == constant)
    {
      loadid=it2->second;
      break;
    }
  }
  
 }	

  if(getNodeType(loadid) == route)
    loadid=getRouteSrc(loadid);

  std::map<int, string>::iterator nameit = nodeid_names.find(loadid);
  return nameit->second;
}


//get the name of the variable to be stored (this function is called for a st_add operation)
string getstorevarname(int id)
{
  /*
     a st_add node has only one outgoing edge (dest).
     dest will have 3 incoming edges. One from st_add, one from an operation containing the value to be stored and the other node indicating the variable name
     */

/* enhanced with arrays. Mahesh version */

  std::multimap<int, int>::iterator it1 = in_edge.find(id);
  int loadid;

 if ( it1->second == 0) 
 { 
  std::multimap<int, int>::iterator it = out_edge.find(id);
  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
  ret = in_edge.equal_range(it->second);
  for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
  {
    if( (getNodeType(it2->second) == constant) ) // || (getNodeType(it2->second) == cgra_select) )	//read-only or recurring variables
    {
      loadid=it2->second;     
    } 
  }

 }

 else 
 {
  std::multimap<int, int>::iterator it = in_edge.find(id);
  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
  ret = in_edge.equal_range(it->second); 
   for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
  { 
    if( getNodeType(it2->second) == constant)
    { 
      loadid=it2->second;
      break; 
    }
  }
  
 }


  std::map<int, string>::iterator nameit = nodeid_names.find(loadid);
  return nameit->second;
}


//return the node id's of all the nodes performing a ld_add/st_add
vector<int> getMemoryNodes()
{
  vector<int> result;
  for(std::map<int, int>::iterator it = nodeid_type.begin(); it != nodeid_type.end(); ++it)
  {
    int id = it->first;
    string nodename;

    if(it->second != route)
    	nodename = getNodeName(id);

    if(it->second == ld_add || it->second == st_add)
    {
//      if(nodename.find("st_add") == string::npos)	//Ignore Store Nodes For Live Variables
      	result.push_back(it->first);
    }
  }
  return result;
}

int getLeftPE(int pe)
{
 int leftpe;

 if(pe%Y == 0)
   leftpe = pe + (Y-1);
 else
   leftpe = (pe - 1);

 return leftpe;
}

/* Fix Me:
   Currently current_time obtained is the time where regular epilog ends
   And Before storing of Live variables start.
   It can be made efficient by many ways such that it starts from 
   last sched time for corresponding PE.
  */
int insert_livevar_store_nodes(int id, int pe, int current_time)
{
  int inserted = 0;
  int row_no = pe/Y;
  int time = current_time;
  while(!inserted)
  {
	if(time_pe_map_livevar.count(time) > 0)
          {
            std::set<int> rows = time_pe_map_livevar[time];

	    if(rows.count(row_no))
            {
	 	time++;
            }  
	    else
	    {	
            	rows.insert(row_no);
                time_pe_map_livevar[time] = rows;
      	        node_schedule_time[id] = time;
                node_schedule_time[id-1] = time;
		inserted=1;
	    } 
          }
          else
          {
 	    node_schedule_time[id] = time;
            node_schedule_time[id-1] = time;
            std::set<int> rows;
            rows.insert(row_no);
            time_pe_map_livevar[time] = rows;
            inserted = 1;
          }
  }

  if(schedule_time_nodes.count(time) > 0)
  {
    std::set<int> operations = schedule_time_nodes[time];
    operations.insert(id);
    operations.insert(id-1);
    schedule_time_nodes[time] = operations;
  }
  else
  {
    std::set<int> operations;
    operations.insert(id);
    operations.insert(id-1);
    schedule_time_nodes[time] = operations;
  }

  return time;

}

int generateLiveVarStoreSchedule(int max_schedule_time, int livenodes)
{
  int sched_time = max_schedule_time+1;
  int store_nodes_per_cgra_cycle = 2*X;
  int max_time = sched_time;
  int max_sched_time = sched_time;

  //Just two nodes store_add and store_data to be scheduled in a row 
  //We map total of store_nodes_per_cgra_cycle nodes per cgra cycle
  for(int i=0; i<livenodes; ++i)
  {
      std::set<int>::iterator it;
      int opID = getLiveNode(i);
      string nodename = getNodeName(opID);
      int livevar_st_add, livevar_data, livevar_data_pe, livevar_add_pe;
            
      node_schedule_time[opID] = sched_time;

      //We should place first store_data node for live-variable
      //It should be placed at same PE where corresponding data is mapped
      //After, we should map st_load node for the same live-variable to PE left to the PE on which st_data node is mapped
      
      if(getNodeType(opID) != st_data)   
	continue;

      livevar_data = getLiveVarData(opID);
      livevar_st_add = opID - 1;	//As we know, store_add and store_data comes in pair, we get nodeid of corresponding store_add node

      if(getNodeType(livevar_data) != constant)	
        livevar_data_pe = getMappedPE(livevar_data, state_kernel); //Node providing live variable data may or may not be in the epilog
      else
	livevar_data_pe = (X*Y/2);	//Randomly Selected PE

      livevar_add_pe = getLeftPE(livevar_data_pe);
      max_time = insert_livevar_store_nodes(opID, livevar_data_pe, sched_time);
      livevar_pe_map.insert(std::pair<int,int>(opID,livevar_data_pe));
      livevar_pe_map.insert(std::pair<int,int>(opID-1,livevar_add_pe));
      max_sched_time = (max_time > max_sched_time) ? max_time : max_sched_time;
  }

  final_livevar_store_size = ((max_sched_time - max_schedule_time) * X * Y);
  livevar_store = new int[final_livevar_store_size];

  //Firstly, initialize each as no-op
  for(int i = 0; i < final_livevar_store_size; i++)
    livevar_store[i] = -1;

  for(int i = sched_time; i <= max_sched_time; i++)
  {
 	//Get Nodes At Current Time And Schedule Them On Their Corresponding PEs
 	if(schedule_time_nodes.count(i) > 0)
        {
            std::set<int> operations = schedule_time_nodes[i];
	    std::set<int>::iterator it;
      	    for(it=operations.begin(); it != operations.end(); ++it)
      	    {
		int nodeID = *it;
		int pe = getLiveVarMappedPE(nodeID);
		int pe_index = ((i-sched_time)*X*Y) + pe;
		livevar_store[pe_index] = nodeID;
	    }
	}
  }

  /* We Do Not Print Mapping of Live Variables 
  cout << "Printing LiveVar Mapping\n";
  for(int i = 0; i < final_livevar_store_size; i++)
    cout << i << ": " << livevar_store[i] << "\n"; */

  return max_time;
}


//TODO
void generateINITinstructions(char* objfile)
{
  /*
     This function is responsible for generating the LDi, LDMi and LDUi instructions that initialize the fixed RF with
     the load/store addresses
Steps:
1. Get a list of all the nodes performing a ld_add or st_add
2. for each node
{
pe = get the PE it is mapped to.
n = get the number of memory operations mapped to that PE
if(n>0)
reg_num = n;
else
reg_num = 0;
if(pe_mem_op_map.contains(pe))
pe_mem_op_map[pe]++;
else
pe_mem_op_map.insert(pe,1);

mem_node_regNum.insert(node,reg_num);

generate 3 instructions, LDi, LDMi and LDUi for the INIT state of this PE
varname = getld/st varname;
addr = get address of varname from the symbol table
  //the load immediate instructions have the LMUX as immediate and their WE set to 1.
  //the RW bits tell us the register number where we want to write the address
  //LDi
  immediate = addr & 0x00000fff
  //LDMi
  immediate = (addr & 0x00fff000) >> 12
  //LDUi
  immediate = (addr & 0xff000000) >>24

  }
  */

vector<int> mem_nodes = getMemoryNodes();

if(mem_nodes.size() > 0)
{
  for(int i=0;i<mem_nodes.size();++i)
  {
    int node = mem_nodes[i];
    int pe;
    cout << "Memory Node: " << node << endl;
    if(isLiveStoreNode(node))
	pe = getLiveVarMappedPE(node);
    else
    	pe = getMappedPE(node, state_kernel);

    int num_mem_ops = (pe_mem_op_map.count(pe) == 0)?0: pe_mem_op_map[pe];
    int reg_num = num_mem_ops;

    mem_node_regNum[node] = reg_num;

    pe_mem_op_map[pe] = num_mem_ops+1;

    //update maxmemory operation count
    maxMemoryOperations = ((num_mem_ops+1) > maxMemoryOperations)? (num_mem_ops+1):maxMemoryOperations;

    string var = (getNodeType(node) == ld_add)? getloadvarname(node):getstorevarname(node);

  int addr = getVariableAddress(var,objfile);

   int id = getNodeType(node); 
   std::multimap<int, int>::iterator it1 = in_edge.find(node);  
   //printf("\n%x\t",addr);
   //cout<<node<<"\t"<<pe<<"\t"<<addr<<"\t"<<reg_num<<endl;

 if (id == ld_add || id == st_add) 
  {
   if ( it1->second == 0) 
    { 
   printf("\n%x\t",addr);
   cout<<node<<"\t"<<pe<<"\t"<<addr<<"\t"<<reg_num<<endl;

     int LDi_imm = addr & 0x00000fff;
     int LDMi_imm = (addr & 0x00fff000) >> 12;
     int LDUi_imm = (addr & 0xff00000) >> 24;
 

     CGRA_Instruction LDi_ins(LDi,0,Immediate,Register,0,0,reg_num,1,LDi_imm,0,0);
     CGRA_Instruction LDMi_ins(LDMi,0,Immediate,Register,0,0,reg_num,1,LDMi_imm,0,0);
     CGRA_Instruction LDUi_ins(LDUi,0,Immediate,Register,0,0,reg_num,1,LDUi_imm,0,0);

     unsigned int dec1= LDi_ins.DecodeInstruction(&LDi_ins),dec2 = LDMi_ins.DecodeInstruction(&LDMi_ins), dec3 = LDUi_ins.DecodeInstruction(&LDUi_ins);

     printf("%x: %x: %x ",dec1,dec2,dec3);

     std::vector<CGRA_Instruction> ins_set;
     ins_set.push_back(LDi_ins);
     ins_set.push_back(LDMi_ins);
     ins_set.push_back(LDUi_ins);

     initInstructions.insert(std::pair<int,std::vector<CGRA_Instruction> >(pe,ins_set));

  }
 else  
  { 
   printf("\ngetting array addresses");
   //printf("\n%x\t",addr); 
   getArrayAddress(pe,addr,node,reg_num,maxMemoryOperations,num_mem_ops);  
  } 
 }
}
}
}
//This function generates a no operation instruction
CGRA_Instruction generateNOOP()
{
  CGRA_Instruction noop(NOOP,0,Self,Self,0,0,0,0,0,0,0);
  return noop;
}


/*
   This function is responsible for generating prolog instructions
Steps:
1. get total prolog cycles
2. max_init_ins = get max number of memory ops mapped to a PE
3. total_init_cycles = max_init_ins*3
4. if((total_init_cycles%II) != 0), add a few noop cycles
This step is done to make sure that the registers are rotated a cycle before the actual prolog instructions start
5. for each pe, generate the init instructions and store the decoded instruction in the final_prolog array
6. add the dummy noop instructions
7. get the decoded prolog instructions and populate the final_prolog array
*/

void generateProlog()
{ 
  int total_cycles;
  int regi_prolog_cycles = prolog_size/(X*Y);
  int init_cycles = maxMemoryOperations*3;
  //int init_cycles_array = ArrayOperations*maxArrayMem*3;
  //int init_cycles = init_cycles_scalar + init_cycles_array; 
  int noop_cycles=0;
//  printf("\nII = %d\tgenerateProlog\n",II);
  if(init_cycles%II != 0)
  {
    noop_cycles = II - (init_cycles%II);
  }
  total_cycles = init_cycles + noop_cycles + regi_prolog_cycles;

  final_prolog_size = total_cycles * X * Y;

  final_prolog = new unsigned int[final_prolog_size];

  CGRA_Instruction noop_ins = generateNOOP();
  unsigned int noop_decoded = noop_ins.DecodeInstruction(&noop_ins);

  //populate the final_prolog array with init instructions

  //FOR EACH PE
  for(int i=0; i<(X*Y); ++i)
  {   
    //FOR EACH MEM OPERATION
    if(initInstructions.count(i) > 0)
    {
      std::pair <std::multimap<int,std::vector<CGRA_Instruction> >::iterator, std::multimap<int,std::vector<CGRA_Instruction> >::iterator> ret;
      ret = initInstructions.equal_range(i);
      int j=0;

      //FOR EACH LD_IMM OPERATION
      for (std::multimap<int,std::vector<CGRA_Instruction> >::iterator it=ret.first; it!=ret.second; ++it)
      {
        std::vector<CGRA_Instruction> LDI_ins = it->second;
        for(int k = 0;k<LDI_ins.size(); ++k)
        {
          final_prolog[i + (X*Y)*j] = LDI_ins[k].DecodeInstruction(&LDI_ins[k]);
          j++;
        }
      }

      //fill the rest of init cycles with noops
      if(j < init_cycles)
      {
        while(j< init_cycles)
        {
          final_prolog[i + (X*Y)*j] = noop_decoded;
          j++;
        }
      }


    }

    //fll with only noops
    else
    {
      for(int j = 0;j<init_cycles;++j)
        final_prolog[i + (X*Y)*j] = noop_decoded;
    }
  }

  //populate the final_prolog array with dummy noop instructions

  if(noop_cycles > 0)
  {
    for(int i = 0; i< (X*Y); ++i)
    {
      for (int j = init_cycles; j < (init_cycles + noop_cycles) ; ++j)
      {
        final_prolog[i + (X*Y)*j] = noop_decoded;
      }
    }
  }

  int prolog_start = (init_cycles + noop_cycles) * (X*Y);

  for(int i =0; i<prolog_size; ++i)
  {
    if(prolog[i] == -1)
    {   
      final_prolog[prolog_start++] = noop_decoded;
    }
    else
    {
      CGRA_Instruction temp;
      if(getNodeType(prolog[i]) == cgra_select)
      {
        float prolog_cycle = (int) ceil(i/(X*Y));
        float prolog_counter_division = (prolog_cycle/kernel_II);
	int prolog_counter = (int) ceil(prolog_counter_division);

	int distance = getDepenDistance(prolog[i]);
        
	if(prolog_counter <= distance)
	        temp = nodeid_instruction_prolog[prolog[i]];
	else
		temp = nodeid_instruction[prolog[i]];
      }
      else
      {
        temp = nodeid_instruction[prolog[i]];
      }
      final_prolog[prolog_start++] = temp.DecodeInstruction(&temp);
    }
  }

  cout<<"*******PROLOG*********\n";

  for(int i =0; i<final_prolog_size; ++i)
    printf("%d: %x\n",i,final_prolog[i]);
}

void generateKernel()
{
  final_kernel_size = kernel_size;
  final_kernel = new unsigned int[final_kernel_size];

  CGRA_Instruction noop_ins = generateNOOP();
  unsigned int noop_decoded = noop_ins.DecodeInstruction(&noop_ins);

  for(int i =0; i<kernel_size; ++i)
  {
    if(kernel[i] == -1)
    {   
      final_kernel[i] = noop_decoded;
    }
    else
    {
      CGRA_Instruction temp = nodeid_instruction[kernel[i]];
      final_kernel[i] = temp.DecodeInstruction(&temp);
    }
  }

  cout<<"*******KERNEl*********\n";

  for(int i =0; i<final_kernel_size; ++i)
    printf("%d: %x\n",i,final_kernel[i]);

}


void generateEpilog()
{
  //Print LiveVar Store Size To livevar_st_ins_count.txt
  ofstream myfile;
  myfile.open("livevar_st_ins_count.txt");
  myfile << final_livevar_store_size;
  myfile.close();

  final_epilog_size = epilog_size + final_livevar_store_size;
  final_epilog = new unsigned int[final_epilog_size];

  CGRA_Instruction noop_ins = generateNOOP();
  unsigned int noop_decoded = noop_ins.DecodeInstruction(&noop_ins);

  for(int i =0; i<epilog_size; ++i)
  {
    if(epilog[i] == -1)
    {   
      final_epilog[i] = noop_decoded;
    }
    else
    {
      CGRA_Instruction temp = nodeid_instruction[epilog[i]];
      final_epilog[i] = temp.DecodeInstruction(&temp);
    }
  }


  //Now We Generate LiveVariable Store Instructions
  final_livevar_store = new unsigned int[final_livevar_store_size];

  for(int i =0; i<final_livevar_store_size; ++i)
  {
    if(livevar_store[i] == -1)
    {   
      final_epilog[i+epilog_size] = noop_decoded;
    }
    else
    {
      CGRA_Instruction temp = nodeid_instruction[livevar_store[i]];
      final_epilog[i+epilog_size] = temp.DecodeInstruction(&temp);
    }
  }

  cout<<"*******EPILOG*********\n";

  for(int i =0; i<final_epilog_size; ++i)
    printf("%d: %x\n",i,final_epilog[i]);

}

void printSet(std::set<int> &arg)
{
  for(std::set<int>::iterator it = arg.begin(); it!=arg.end(); ++it)
    cout << *it << "\t";
  cout << "\n";
} 

/* Function Below Generates Instructions For Non-Phi Nodes */

void generateInstructions(std::set<int> &nodes)
{
  OPCode opc;
  int predic = 0;
  PEInputMux lmux,rmux;
  int reg1=0,reg2=0,wreg=0;
  bool we,abAssert,dbAssert;
  int immediate=0;


  //	CGRA_Instruction(OPCode opc,int predic,PEInputMux LMuxSel,PEInputMux RMuxSel,\
  int RRegAdd1,int RRegAdd2, int WAdd, bool WE, int ImmVal, bool EDMAdd, bool DMData);

  //Generate Instructions For All Nodes, Except Phi Nodes
  for(std::set<int>::iterator it = nodes.begin(); it!=nodes.end(); ++it)
  {
    int node = *it;
    opc = getOpCode(node);

    //if(getNodeType(node) == cgra_select) 
    	//continue;

    lmux = getLMuxSelector(node, state_kernel);
    rmux = getRMuxSelector(node, state_kernel);

    if(lmux == Register)
    {
      reg1 = getReg1Address(node,lmux,state_kernel);
    }
    else
      reg1 = 0;

    if(rmux == Register)
      reg2 = getReg2Address(node,rmux,state_kernel);
    else
      reg2 = 0;

    releaseRegisters(node,state_kernel);

    we = isWriteEnabled(node);
    if(we)
    {
      wreg =getWriteRegAddress(node,state_kernel);
    }
    else
      wreg = 0;

    

    node_Output_Register[node] = wreg;
    immediate = getImmediate(node);

    if(getNodeType(node) == cgra_select) immediate = 0;   //For loop-carried phi operand, immediate = 0

    abAssert = isAddressBusAssert(node);
    dbAssert = isDataBusAssert(node);
    printf("\nFOR NODE %d:opcode:%d lmux:%d rmux:%d reg1:%d reg2:%d we:%d wreg:%d imm:%d ab:%d db:%d\n",node,opc,lmux,rmux,reg1,reg2,we,wreg,immediate,abAssert,dbAssert);

    CGRA_Instruction node_ins(opc,predic,lmux,rmux,reg1,reg2,wreg,we,immediate,abAssert,dbAssert);

    nodeid_instruction[node] = node_ins;


    unsigned int decoded = node_ins.DecodeInstruction(&node_ins);
    printf("Decoded %x\n",decoded);
  
  }  
}

void generatePhiInstructions(std::set<int> &nodes)
{
  OPCode opc;
  int predic = 0;
  PEInputMux lmux,rmux;
  int reg1=0,reg2=0,wreg=0;
  bool we,abAssert,dbAssert;
  int immediate=0;

  //Now generate instruction for phi nodes
  //We need to do this later here as now all predessessor nodes are placed 

 for(std::set<int>::iterator it = nodes.begin(); it!=nodes.end(); ++it)
 {
   int node = *it;
   opc = getOpCode(node); 
   int node_type = getNodeType(node);

   if(node_type != cgra_select)
   	continue;

   lmux = getLMuxSelector(node, state_kernel);
   rmux = getRMuxSelector(node, state_kernel);
                                                                                                                                                                        
   if(lmux == Register)
     reg1 = getReg1Address(node,lmux,state_kernel);
   else
     reg1 = 0;
                                                                                                                                                                          
   if(rmux == Register)
     reg2 = getReg2Address(node,rmux,state_kernel);
   else
     reg2 = 0;
                                                                                                                                                                          
   releaseRegisters(node,state_kernel);
                                                                                                                                                                          
   we = isWriteEnabled(node);
   if(we)
     wreg =getWriteRegAddress(node,state_kernel);
   else
     wreg = 0;
   node_Output_Register[node] = wreg;
   immediate = getImmediate(node);
                                                                                                                                                                          
   if(getNodeType(node) == cgra_select) immediate = 0;   //For loop-carried phi operand, immediate = 0
                                                                                                                                                                          
   abAssert = isAddressBusAssert(node);
   dbAssert = isDataBusAssert(node);
                                                                                                                                                                          
   lmux = getlmuxphi(node);
   rmux = getrmuxphi(node);
   immediate = getimmediatephi(node);

   reg1 = 0; 
   reg2 = 0;

   printf("\nPhi! Prolog! FOR NODE %d:opcode:%d lmux:%d rmux:%d reg1:%d reg2:%d we:%d wreg:%d imm:%d ab:%d db:%d\n",node,opc,lmux,rmux,reg1,reg2,we,wreg,immediate,abAssert,dbAssert);
                                                                                                             
   CGRA_Instruction node_ins_prolog(opc,predic,lmux,rmux,reg1,reg2,wreg,we,immediate,abAssert,dbAssert);
                                                                                                                                      
   nodeid_instruction_prolog[node] = node_ins_prolog;
                                                                                                                                          
   unsigned int decoded = node_ins_prolog.DecodeInstruction(&node_ins_prolog);
   
   printf("Decoded %x\n",decoded);

  }
}


void generateStoreInstructions(std::set<int> &nodes)
{
  OPCode opc;
  int predic = 0;
  PEInputMux lmux,rmux;
  int reg1=0,reg2=0,wreg=0;
  bool we,abAssert,dbAssert;
  int immediate=0;

  //Now generate instruction for live variable nodes
  //We need to do this later here as now all predessessor nodes are placed 

 for(std::set<int>::iterator it = nodes.begin(); it!=nodes.end(); ++it)
 {
   int node = *it;
   opc = getOpCode(node); 
   int node_type = getNodeType(node);

   lmux = getLMuxSelector(node, state_kernel); 
   rmux = getRMuxSelector(node, state_kernel); 
                                                                                                                                                                        
   if(lmux == Register)
     reg1 = getReg1Address(node,lmux,state_kernel);
   else
     reg1 = 0;
                                                                                                                                                                          
   if(rmux == Register)
     reg2 = getReg2Address(node,rmux,state_kernel);
   else
     reg2 = 0;
                                                                                                                                                                          
   releaseRegisters(node,state_kernel); 

   //if(node == 123) reg1 = 3;                            
                                                                                                                                              
   we = isWriteEnabled(node);
   if(we)
     wreg =getWriteRegAddress(node,state_kernel);
   else
     wreg = 0;
   node_Output_Register[node] = wreg; 
   immediate = getImmediate(node); 
                                                                                                                                                                                                                                                                                                                                                   
   abAssert = isAddressBusAssert(node);
   dbAssert = isDataBusAssert(node);
        
   printf("\nFOR NODE %d:opcode:%d lmux:%d rmux:%d reg1:%d reg2:%d we:%d wreg:%d imm:%d ab:%d db:%d\n",node,opc,lmux,rmux,reg1,reg2,we,wreg,immediate,abAssert,dbAssert);

   CGRA_Instruction node_ins(opc,predic,lmux,rmux,reg1,reg2,wreg,we,immediate,abAssert,dbAssert);

   nodeid_instruction[node] = node_ins;

   unsigned int decoded = node_ins.DecodeInstruction(&node_ins);
   printf("Decoded %x\n",decoded);
   
  }
}

void dumpProlog()
{
  FILE* prologFile;
  prologFile = fopen("prolog_ins.bin","wb");
  fwrite(&final_prolog_size,sizeof(int),1,prologFile);
  fwrite(final_prolog,sizeof(int),final_prolog_size,prologFile);
  fclose(prologFile);
}
void dumpKernel()
{
  FILE* kernelFile;
  kernelFile = fopen("kernel_ins.bin","wb");
  fwrite(&final_kernel_size,sizeof(int),1,kernelFile);
  fwrite(final_kernel,sizeof(int),final_kernel_size,kernelFile);
  fclose(kernelFile);
}
void dumpEpilog()
{
  FILE* epilogFile;
  epilogFile = fopen("epilog_ins.bin","wb");
  fwrite(&final_epilog_size,sizeof(int),1,epilogFile);
  fwrite(final_epilog,sizeof(int),final_epilog_size,epilogFile);
  fclose(epilogFile);
}

//driver function
int main(int argc, char* argv[])
{
  if(argc<13)
  {
    cout << "Usage opcodegen FINALNODEFILE REGI_EDGEFILE LLVMNODEFILE LLVMEDGEFILE OBJFILE PrologFile KernelFile EpilogFile X Y LIVENODEFILE LIVEEDGEFILE";
    return -1;
  }

  //CGRA DIMENSIONS
  X = atoi(argv[9]);
  Y = atoi(argv[10]);

  string line, nodename;
  int nodeID,node_type,other_nodeID;
  int livenodes=0;
  //Read the final node file
  ifstream finalnodefile (argv[1]);
  if(finalnodefile.is_open())
  {
    while ( getline(finalnodefile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> node_type;
      nodeid_type.insert(std::pair<int,int>(nodeID,node_type));
      if(node_type == route)
        routingNodes.push_back(nodeID);
    }
  }
  finalnodefile.close();


  //read the Edge file dumped by RegiMap
  ifstream regiEdgeFile (argv[2]);
  if(regiEdgeFile.is_open())
  {
    while ( getline(regiEdgeFile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> other_nodeID;
      cout<<"\nUPDATING EDGES " <<other_nodeID<<":"<<nodeID<<endl;
      out_edge.insert(std::pair<int,int>(nodeID,other_nodeID));
      in_edge.insert(std::pair<int,int>(other_nodeID,nodeID));
    }
  }
  regiEdgeFile.close();

  //read the node file dumped by llvm (dfg generator) to get the name of nodes
  //(used for constant nodes)
  ifstream llvmNodeFile (argv[3]);
  if(llvmNodeFile.is_open())
  {
    while ( getline(llvmNodeFile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> node_type >> nodename ;
      //cout << nodeID << "\t" << node_type << "\t" << nodename  << endl;
      nodeid_names.insert(std::pair<int,string>(nodeID,nodename));
    }
  }
  llvmNodeFile.close();


  //read the llvm generated edge file
  //populate the out edge and in edge maps.
  //populate the operand orders

  //IMPORTANT: The out_edge and in_edge map contain the edges genrated by RegiMap
  //and the edges from the constant nodes to the other nodes.

  ifstream llvmEdgeFile (argv[4]);
  if(llvmEdgeFile.is_open())
  {
    while ( getline(llvmEdgeFile,line) )
    {
      int operandOrder,distance;
      string dependencyType;
      istringstream strout(line);
      strout >> nodeID >> other_nodeID >> distance >> dependencyType >> operandOrder;
      std::pair<int,int> outGoingEdge(nodeID,other_nodeID);
      operand_order_map.insert(std::pair< std::pair<int,int>,int >(outGoingEdge,operandOrder));
      if(getNodeType(nodeID) == constant)
      {
        cout<<"\nUPDATING EDGES " <<other_nodeID<<":"<<nodeID<<endl;
        out_edge.insert(std::pair<int,int>(nodeID,other_nodeID));
        in_edge.insert(std::pair<int,int>(other_nodeID,nodeID));
      }

      if(getNodeType(other_nodeID) == cgra_select) 	//In case of Phi or Select Node
      {
	if(distance > 0)
	{        
		cout<<"\nUPDATING DEPENDENCY EDGES FOR NODE  " << other_nodeID <<":"<< distance << endl;
		to_node_dependency_distance.insert(std::pair<int,int>(other_nodeID,distance));
        	select_node_condition.insert(std::pair<int,bool>(other_nodeID,1));
		select_node_counter.insert(std::pair<int,int>(other_nodeID,0));
		select_phi_node_result.insert(std::pair<int,int>(other_nodeID,nodeID));
	}
      }

    }
  }
  llvmEdgeFile.close();

  //read the live-node file dumped by llvm (dfg generator) to get the information about live nodes and corresponding store nodes
  //(used for live nodes only, to store data back into the memory for future use of main processor)
  ifstream LiveNodeFile (argv[11]);
  if(LiveNodeFile.is_open())
  {
    while ( getline(LiveNodeFile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> node_type >> nodename ;
//      if( (nodename.find("st_add") != string::npos) | (nodename.find("st_data") != string::npos) )
//	nodeid_type.insert(std::pair<int,int>(nodeID,node_type));

      //Add Only If It Is Not Available Previously - Applicable to store_add and store_data nodes for live variables
      std::map<int, int>::iterator it;
      int livenode_present=0;
      for(it = nodeid_type.begin(); it != nodeid_type.end(); ++it)
      {
 	if(it->first == nodeID) 
	{
	  livenode_present=1;
	  break;
	}
      }
      if(livenode_present == 0)
      {
	nodeid_names.insert(std::pair<int,string>(nodeID,nodename));
        nodeid_type.insert(std::pair<int,int>(nodeID,node_type));
        livevar_node_list.insert(std::pair<int,int>(livenodes,nodeID));
	livenodes++;
      }
    }
  }
  LiveNodeFile.close();

  //read the llvm generated live-variable's edge file
  //populate the edges for live variable
  //populate the operand orders
  //All edges are required and new so should be added

  ifstream LiveEdgeFile (argv[12]);
  if(LiveEdgeFile.is_open())
  {
    while ( getline(LiveEdgeFile,line) )
    {
      int operandOrder,distance;
      string dependencyType;
      istringstream strout(line);
      strout >> nodeID >> other_nodeID >> distance >> dependencyType >> operandOrder;
      std::pair<int,int> outGoingEdge(nodeID,other_nodeID);

      operand_order_map.insert(std::pair< std::pair<int,int>,int >(outGoingEdge,operandOrder));
      cout<<"\nUPDATING EDGES " <<other_nodeID<<":"<<nodeID<<endl;
      out_edge.insert(std::pair<int,int>(nodeID,other_nodeID));
      in_edge.insert(std::pair<int,int>(other_nodeID,nodeID));
    }
  }
  LiveEdgeFile.close();

  //update the operand orders to incorporate routing nodes from the dfg
  //generated by RegiMAP
  updateOperandOrder();

  //read the prolog file
  int opID,num_ops,i=0; 
  ifstream prologFile (argv[6]);
  if(prologFile.is_open())
  {
    while ( getline(prologFile,line) )
    {
      istringstream strout(line);
      strout >> prolog_size;
    }
    prolog = new int[prolog_size];  	    
  }
  prologFile.close();
  II = prolog_size/(X*Y);
//  printf("\nII = %d\tprolog_size\n",II);
  prologFile.open(argv[6], ifstream::in);
  cout << "file ptr:"<<prologFile.tellg()<<"\topen:"<<prologFile.is_open() <<"\t prolog_size:"<< prolog_size<<"\n"<<endl;
  if(prologFile.is_open())
  {
    while ( getline(prologFile,line) )
    {
      istringstream strout(line);
      strout >> opID;
      if(i<prolog_size)
        prolog[i++] = opID;
    }
  }  
  prologFile.close();


  //read the kernel file
  i=0;
  ifstream kernelFile (argv[7]);
  if(kernelFile.is_open())
  {
    while ( getline(kernelFile,line) )
    {
      istringstream strout(line);
      strout >> kernel_size;
    }
    kernel = new int[kernel_size];  	    
  }
  kernel_II = kernel_size/(X*Y);
  kernelFile.close();
  int numRegisters,sched_t,max_schedule_time=0;
  kernelFile.open(argv[7], ifstream::in);
  if(kernelFile.is_open())
  {
    while ( getline(kernelFile,line) )
    {
      if(i<kernel_size)
      {
        istringstream strout(line);
        strout >> opID >> numRegisters >> sched_t;

        int t=getTime(i);
        int pe=getPE(i);

        if(opID != -1)
        {
          cout<<opID<<"\t"<<sched_t<<endl;
          node_schedule_time[opID] = sched_t;

          max_schedule_time = (sched_t>max_schedule_time)?sched_t:max_schedule_time;

          if(schedule_time_nodes.count(sched_t) > 0)
          {

            std::set<int> operations = schedule_time_nodes[sched_t];
            operations.insert(opID);
            schedule_time_nodes[sched_t] = operations;
          }
          else
          {
            std::set<int> operations;
            operations.insert(opID);
            schedule_time_nodes[sched_t] = operations;
          }
        }
        std::pair<int,int> pe_t(pe,t);
        pe_time_Registers_map[pe_t] = numRegisters;
        kernel[i++] = opID;
      }
    }
  }  
  kernelFile.close();


  //read the epilog file
  i=0;
  ifstream epilogFile (argv[8]);
  if(epilogFile.is_open())
  {
    while ( getline(epilogFile,line) )
    {
      istringstream strout(line);
      strout >> epilog_size;
    }
    epilog = new int[epilog_size];  	    
  }
  epilogFile.close();
  epilogFile.open(argv[8], ifstream::in);
  if(epilogFile.is_open())
  {
    while ( getline(epilogFile,line) )
    {
      istringstream strout(line);
      strout >> opID;
      if(i<epilog_size)
        epilog[i++] = opID;
    }
  }  
  epilogFile.close();

  //POPULATE THE PROLOG, KERNEL and EPILOG related maps
  cout <<"\n"<< prolog_size << endl << kernel_size<<endl<<epilog_size<<endl;		
  for(int j=0;j<prolog_size;j++)
  {
    if(prolog[j] != -1)
    {
      int pe,t,node;
      pe = getPE(j);
      node = prolog[j];
      t = getTime(j);
      std::pair<int,int> pe_time(pe,t);
      node_time_map_prolog.insert(std::pair<int,int>(node,t));
      prolog_map.insert(std::pair<int,int>(node,pe));
    }
  }

  cout<<"*********KERNEL*****************\n";
  for(int j=0;j<kernel_size;j++)
  {
    if(kernel[j] != -1)
    {
      int pe,t,node;
      pe = getPE(j);
      node = kernel[j];
      t = getTime(j);
      std::pair<int,int> pe_time(pe,t);
      node_time_map_kernel.insert(std::pair<int,int>(node,t));
      kernel_map.insert(std::pair<int,int>(node,pe));
    }
  }

  cout<<"*********EPILOG*****************\n";
  for(int j=0;j<epilog_size;j++)
  {
    if(epilog[j] != -1)
    {
      int pe,t,node;
      pe = getPE(j);
      node = epilog[j];
      t = getTime(j);
      std::pair<int,int> pe_time(pe,t);
      node_time_map_epilog.insert(std::pair<int,int>(node,t));
      epilog_map.insert(std::pair<int,int>(node,pe));
    }
  }

  int totalPEs = X*Y;
  std::set<int> freeRegs;
  for(int i=0;i<REGFILESIZE;++i)
  {
    freeRegs.insert(i);
  }
  //initialize the free registers ma for each PE
  for(int i=0;i<totalPEs;++i)
  {
    pe_free_registers[i] = freeRegs;
  } 

  int max_time = generateLiveVarStoreSchedule(max_schedule_time, livenodes);

  generateINITinstructions(argv[5]);

  //Generate Instruction For Nodes Other Than Phi Nodes
  cout << "\n****** Generating Instructions For Non-Phi Nodes *****\n";
  for(int i=0; i<=max_schedule_time; ++i)
  {
    if(schedule_time_nodes.count(i) > 0)
    {
      std::set<int> nodesAtTime = schedule_time_nodes.find(i)->second;
      std::set<int>::iterator it;
      std::set<int> OtherThanPhiAtTime;
      for(it=nodesAtTime.begin(); it != nodesAtTime.end(); ++it)
      {	
      	if(getNodeType(*it) != cgra_select)
        	OtherThanPhiAtTime.insert(*it);
      }
      cout<<"\nNODES SCHEDULED AT "<<i<<"\n";
      printSet(OtherThanPhiAtTime);
      generateInstructions(OtherThanPhiAtTime);
    }
  }

  cout << "\n****** Generating Instructions For Phi Nodes *****\n";
  //Generate Instruction For Nodes Other Than Phi Nodes
  for(int i=0; i<=max_schedule_time; ++i)
  {
    if(schedule_time_nodes.count(i) > 0)
    {
      std::set<int> nodesAtTime = schedule_time_nodes.find(i)->second;
      std::set<int>::iterator it;
      std::set<int> PhiAtTime;
      int phi_node_available = 0;
      for(it=nodesAtTime.begin(); it != nodesAtTime.end(); ++it)
      {	
      	if(getNodeType(*it) == cgra_select) 
	{
        	PhiAtTime.insert(*it);
		phi_node_available++;
	}
      }

      if(phi_node_available > 0)
      {
      	cout<<"\nNODES SCHEDULED AT "<<i<<"\n";
      	printSet(PhiAtTime);
      	cout << "Phi Instructions" << endl;
      	generatePhiInstructions(PhiAtTime);
      	cout << "\nKernel Instructions" << endl;
      	generateInstructions(PhiAtTime);
      }
    }
  }

  cout << "\n****** Generating Instructions For Store Nodes For Live Variables*****\n";
  int sched_time = max_schedule_time+1;
  //int store_nodes_per_cgra_cycle = 2*X;
  //int remaining=1;
  
  for(i = sched_time; i<= max_time; i++)
  {
    if(schedule_time_nodes.count(i) > 0)
    {
      std::set<int> LiveNodesAtTime = schedule_time_nodes.find(i)->second;
      std::set<int>::iterator it;

      cout<<"\nNODES SCHEDULED AT "<<i<<"\n";
      cout<<"\nNODES SCHEDULED AT STORE CYCLE "<< (i-sched_time) <<"\n";
      printSet(LiveNodesAtTime);
      generateStoreInstructions(LiveNodesAtTime);
    }
  }

  generateProlog();
  generateKernel();
  generateEpilog();

  dumpProlog();
  dumpKernel();
  dumpEpilog();
  
  return 0;
}
